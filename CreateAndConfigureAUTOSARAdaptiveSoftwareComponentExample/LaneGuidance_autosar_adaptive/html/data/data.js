var dataJson = {"arch":{"ispc":false,"isunix":true,"ismac":false},"build":"LaneGuidance","ref":false,"files":[{"name":"LaneGuidance.cpp","type":"source","group":"model","path":"/home/dahyun/Documents/MATLAB/Examples/R2023b/autosarblockset/CreateAndConfigureAUTOSARAdaptiveSoftwareComponentExample/LaneGuidance_autosar_adaptive","tag":"","groupDisplay":"Model files","code":"//\n//  LaneGuidance.cpp\n//\n//  Academic License - for use in teaching, academic research, and meeting\n//  course requirements at degree granting institutions only.  Not for\n//  government, commercial, or other organizational use.\n//\n//  Code generation for model \"LaneGuidance\".\n//\n//  Model version              : 9.0\n//  Simulink Coder version : 23.2 (R2023b) 01-Aug-2023\n//  C++ source code generated on : Wed Jan 24 16:40:53 2024\n//\n//  Target selection: autosar_adaptive.tlc\n//  Embedded hardware selection: Intel->x86-64 (Linux 64)\n//  Code generation objectives: Unspecified\n//  Validation result: Not run\n\n\n#include \"LaneGuidance.h\"\n#include <stdint.h>\n\n//\n// Output and update for action system:\n//    '<S1>/IfActionSS'\n//    '<S1>/IfActionSS1'\n//    '<S1>/IfActionSS2'\n//    '<S1>/IfActionSS3'\n//    '<S1>/IfActionSS4'\n//    '<S1>/IfActionSS5'\n//\nvoid LaneGuidance::LaneGuidance_IfActionSS(double rtu_In1, double *rty_Out1)\n{\n  // SignalConversion generated from: '<S2>/In1'\n  *rty_Out1 = rtu_In1;\n}\n\nvoid LaneGuidance::RequiredPortLeftLaneDistanceReceive(ara::com::SamplePtr<\n  proxy::events::LeftLaneDistance::SampleType const > elementPtr)\n{\n  // Receive: '<Root>/Event Receive'\n  LaneGuidance_B.EventReceive = *elementPtr;\n}\n\nvoid LaneGuidance::RequiredPortLeftTurnIndicatorReceive(ara::com::SamplePtr<\n  proxy::events::LeftTurnIndicator::SampleType const > elementPtr)\n{\n  // Receive: '<Root>/Event Receive1'\n  LaneGuidance_B.EventReceive1 = *elementPtr;\n}\n\nvoid LaneGuidance::RequiredPortLeftCarInBlindSpotReceive(ara::com::SamplePtr<\n  proxy::events::LeftCarInBlindSpot::SampleType const > elementPtr)\n{\n  // Receive: '<Root>/Event Receive2'\n  LaneGuidance_B.EventReceive2 = *elementPtr;\n}\n\nvoid LaneGuidance::RequiredPortRightLaneDistanceReceive(ara::com::SamplePtr<\n  proxy::events::RightLaneDistance::SampleType const > elementPtr)\n{\n  // Receive: '<Root>/Event Receive3'\n  LaneGuidance_B.EventReceive3 = *elementPtr;\n}\n\nvoid LaneGuidance::RequiredPortRightTurnIndicatorReceive(ara::com::SamplePtr<\n  proxy::events::RightTurnIndicator::SampleType const > elementPtr)\n{\n  // Receive: '<Root>/Event Receive4'\n  LaneGuidance_B.EventReceive4 = *elementPtr;\n}\n\nvoid LaneGuidance::RequiredPortRightCarInBlindSpotReceive(ara::com::SamplePtr<\n  proxy::events::RightCarInBlindSpot::SampleType const > elementPtr)\n{\n  // Receive: '<Root>/Event Receive5'\n  LaneGuidance_B.EventReceive5 = *elementPtr;\n}\n\n// Model step function\nvoid LaneGuidance::step()\n{\n  std::shared_ptr<ara::core::Result<size_t>> resultPtr;\n  double rtb_Merge1;\n  if (RequiredPort) {\n    resultPtr = std::make_shared< ara::core::Result<size_t> >\n      (RequiredPort->LeftLaneDistance.GetNewSamples(std::move(std::bind\n         (&LaneGuidance::RequiredPortLeftLaneDistanceReceive, this, std::\n          placeholders::_1)), 1U));\n    resultPtr->ValueOrThrow();\n  }\n\n  if (RequiredPort) {\n    resultPtr = std::make_shared< ara::core::Result<size_t> >\n      (RequiredPort->LeftTurnIndicator.GetNewSamples(std::move(std::bind\n         (&LaneGuidance::RequiredPortLeftTurnIndicatorReceive, this, std::\n          placeholders::_1)), 1U));\n    resultPtr->ValueOrThrow();\n  }\n\n  if (RequiredPort) {\n    resultPtr = std::make_shared< ara::core::Result<size_t> >\n      (RequiredPort->LeftCarInBlindSpot.GetNewSamples(std::move(std::bind\n         (&LaneGuidance::RequiredPortLeftCarInBlindSpotReceive, this, std::\n          placeholders::_1)), 1U));\n    resultPtr->ValueOrThrow();\n  }\n\n  // If: '<S1>/If' incorporates:\n  //   Constant: '<S1>/Constant'\n  //   Constant: '<S1>/Constant1'\n  //   Constant: '<S1>/Constant2'\n\n  if (LaneGuidance_B.EventReceive2 > 0.0) {\n    // Outputs for IfAction SubSystem: '<S1>/IfActionSS' incorporates:\n    //   ActionPort: '<S2>/Action Port'\n\n    LaneGuidance_IfActionSS(1.0, &rtb_Merge1);\n\n    // End of Outputs for SubSystem: '<S1>/IfActionSS'\n  } else if ((LaneGuidance_B.EventReceive1 == 0.0) &&\n             (LaneGuidance_B.EventReceive < 0.1)) {\n    // Outputs for IfAction SubSystem: '<S1>/IfActionSS1' incorporates:\n    //   ActionPort: '<S3>/Action Port'\n\n    LaneGuidance_IfActionSS(0.0, &rtb_Merge1);\n\n    // End of Outputs for SubSystem: '<S1>/IfActionSS1'\n  } else {\n    // Outputs for IfAction SubSystem: '<S1>/IfActionSS2' incorporates:\n    //   ActionPort: '<S4>/Action Port'\n\n    LaneGuidance_IfActionSS(1.0, &rtb_Merge1);\n\n    // End of Outputs for SubSystem: '<S1>/IfActionSS2'\n  }\n\n  // End of If: '<S1>/If'\n\n  // Send: '<Root>/Event Send'\n  // Send event\n  ProvidedPort->LeftHazardIndicator.Send(rtb_Merge1);\n  if (RequiredPort) {\n    resultPtr = std::make_shared< ara::core::Result<size_t> >\n      (RequiredPort->RightLaneDistance.GetNewSamples(std::move(std::bind\n         (&LaneGuidance::RequiredPortRightLaneDistanceReceive, this, std::\n          placeholders::_1)), 1U));\n    resultPtr->ValueOrThrow();\n  }\n\n  if (RequiredPort) {\n    resultPtr = std::make_shared< ara::core::Result<size_t> >\n      (RequiredPort->RightTurnIndicator.GetNewSamples(std::move(std::bind\n         (&LaneGuidance::RequiredPortRightTurnIndicatorReceive, this, std::\n          placeholders::_1)), 1U));\n    resultPtr->ValueOrThrow();\n  }\n\n  if (RequiredPort) {\n    resultPtr = std::make_shared< ara::core::Result<size_t> >\n      (RequiredPort->RightCarInBlindSpot.GetNewSamples(std::move(std::bind\n         (&LaneGuidance::RequiredPortRightCarInBlindSpotReceive, this, std::\n          placeholders::_1)), 1U));\n    resultPtr->ValueOrThrow();\n  }\n\n  // If: '<S1>/If1' incorporates:\n  //   Constant: '<S1>/Constant'\n  //   Constant: '<S1>/Constant1'\n  //   Constant: '<S1>/Constant2'\n\n  if (LaneGuidance_B.EventReceive5 > 0.0) {\n    // Outputs for IfAction SubSystem: '<S1>/IfActionSS3' incorporates:\n    //   ActionPort: '<S5>/Action Port'\n\n    LaneGuidance_IfActionSS(1.0, &rtb_Merge1);\n\n    // End of Outputs for SubSystem: '<S1>/IfActionSS3'\n  } else if ((LaneGuidance_B.EventReceive4 == 0.0) &&\n             (LaneGuidance_B.EventReceive3 < 0.1)) {\n    // Outputs for IfAction SubSystem: '<S1>/IfActionSS4' incorporates:\n    //   ActionPort: '<S6>/Action Port'\n\n    LaneGuidance_IfActionSS(0.0, &rtb_Merge1);\n\n    // End of Outputs for SubSystem: '<S1>/IfActionSS4'\n  } else {\n    // Outputs for IfAction SubSystem: '<S1>/IfActionSS5' incorporates:\n    //   ActionPort: '<S7>/Action Port'\n\n    LaneGuidance_IfActionSS(1.0, &rtb_Merge1);\n\n    // End of Outputs for SubSystem: '<S1>/IfActionSS5'\n  }\n\n  // End of If: '<S1>/If1'\n\n  // Send: '<Root>/Event Send1'\n  // Send event\n  ProvidedPort->RightHazardIndicator.Send(rtb_Merge1);\n}\n\n// Model initialize function\nvoid LaneGuidance::initialize()\n{\n  {\n    ara::com::ServiceHandleContainer< proxy::RequiredInterfaceProxy::HandleType >\n      handles;\n    std::shared_ptr<ara::core::Result<ara::com::ServiceHandleContainer< proxy::\n      RequiredInterfaceProxy::HandleType >>> resultPtr;\n\n    // Initialize service provider instance - ProvidedPort\n    ProvidedPort = std::make_shared< skeleton::ProvidedInterfaceSkeleton >(ara::\n      com::InstanceIdentifier(ara::core::StringView(\"2\")), ara::com::\n      MethodCallProcessingMode::kEventSingleThread);\n    ProvidedPort->OfferService();\n\n    // Initialize service requester instance - RequiredPort\n    resultPtr = std::make_shared< ara::core::Result<ara::com::\n      ServiceHandleContainer< proxy::RequiredInterfaceProxy::HandleType >> >\n      (proxy::RequiredInterfaceProxy::FindService(ara::com::InstanceIdentifier\n        (ara::core::StringView(\"1\"))));\n    if (resultPtr->HasValue()) {\n      handles = resultPtr->Value();\n      if (handles.size() > 0U) {\n        RequiredPort = std::make_shared< proxy::RequiredInterfaceProxy >\n          (*handles.begin());\n\n        // Subscribe events\n        RequiredPort->LeftCarInBlindSpot.Subscribe(1U);\n        RequiredPort->LeftLaneDistance.Subscribe(1U);\n        RequiredPort->LeftTurnIndicator.Subscribe(1U);\n        RequiredPort->RightCarInBlindSpot.Subscribe(1U);\n        RequiredPort->RightLaneDistance.Subscribe(1U);\n        RequiredPort->RightTurnIndicator.Subscribe(1U);\n      }\n    }\n  }\n}\n\n// Model terminate function\nvoid LaneGuidance::terminate()\n{\n  ProvidedPort->StopOfferService();\n}\n\n// Constructor\nLaneGuidance::LaneGuidance():\n  LaneGuidance_B()\n{\n  // Currently there is no constructor body generated.\n}\n\n// Destructor\n// Currently there is no destructor body generated.\nLaneGuidance::~LaneGuidance() = default;\n"},{"name":"LaneGuidance.h","type":"header","group":"model","path":"/home/dahyun/Documents/MATLAB/Examples/R2023b/autosarblockset/CreateAndConfigureAUTOSARAdaptiveSoftwareComponentExample/LaneGuidance_autosar_adaptive","tag":"","groupDisplay":"Model files","code":"//\n//  LaneGuidance.h\n//\n//  Academic License - for use in teaching, academic research, and meeting\n//  course requirements at degree granting institutions only.  Not for\n//  government, commercial, or other organizational use.\n//\n//  Code generation for model \"LaneGuidance\".\n//\n//  Model version              : 9.0\n//  Simulink Coder version : 23.2 (R2023b) 01-Aug-2023\n//  C++ source code generated on : Wed Jan 24 16:40:53 2024\n//\n//  Target selection: autosar_adaptive.tlc\n//  Embedded hardware selection: Intel->x86-64 (Linux 64)\n//  Code generation objectives: Unspecified\n//  Validation result: Not run\n\n\n#ifndef RTW_HEADER_LaneGuidance_h_\n#define RTW_HEADER_LaneGuidance_h_\n#include <stdbool.h>\n#include <stdint.h>\n#include \"complex_types.h\"\n#include \"providedinterface_skeleton.h\"\n#include \"requiredinterface_proxy.h\"\n#include <stddef.h>\n#include \"LaneGuidance_types.h\"\n#include <memory>\n\n// Class declaration for model LaneGuidance\nclass LaneGuidance final\n{\n  // public data and function members\n public:\n  // Block signals (default storage)\n  struct B_LaneGuidance_T {\n    double EventReceive;               // '<Root>/Event Receive'\n    double EventReceive1;              // '<Root>/Event Receive1'\n    double EventReceive2;              // '<Root>/Event Receive2'\n    double EventReceive3;              // '<Root>/Event Receive3'\n    double EventReceive4;              // '<Root>/Event Receive4'\n    double EventReceive5;              // '<Root>/Event Receive5'\n  };\n\n  // Copy Constructor\n  LaneGuidance(LaneGuidance const&) = delete;\n\n  // Assignment Operator\n  LaneGuidance& operator= (LaneGuidance const&) & = delete;\n\n  // Move Constructor\n  LaneGuidance(LaneGuidance &&) = delete;\n\n  // Move Assignment Operator\n  LaneGuidance& operator= (LaneGuidance &&) = delete;\n\n  // model initialize function\n  void initialize();\n\n  // model step function\n  void step();\n\n  // model terminate function\n  void terminate();\n\n  // Constructor\n  LaneGuidance();\n\n  // Destructor\n  ~LaneGuidance();\n\n  // private data and function members\n private:\n  // Block signals\n  B_LaneGuidance_T LaneGuidance_B;\n  std::shared_ptr<proxy::RequiredInterfaceProxy> RequiredPort;\n  std::shared_ptr<skeleton::ProvidedInterfaceSkeleton> ProvidedPort;\n\n  // private member function(s) for subsystem '<S1>/IfActionSS'\n  static void LaneGuidance_IfActionSS(double rtu_In1, double *rty_Out1);\n\n  // private member function(s) for subsystem '<Root>'\n  void RequiredPortLeftLaneDistanceReceive(ara::com::SamplePtr< proxy::events::\n    LeftLaneDistance::SampleType const > elementPtr);\n  void RequiredPortLeftTurnIndicatorReceive(ara::com::SamplePtr< proxy::events::\n    LeftTurnIndicator::SampleType const > elementPtr);\n  void RequiredPortLeftCarInBlindSpotReceive(ara::com::SamplePtr< proxy::events::\n    LeftCarInBlindSpot::SampleType const > elementPtr);\n  void RequiredPortRightLaneDistanceReceive(ara::com::SamplePtr< proxy::events::\n    RightLaneDistance::SampleType const > elementPtr);\n  void RequiredPortRightTurnIndicatorReceive(ara::com::SamplePtr< proxy::events::\n    RightTurnIndicator::SampleType const > elementPtr);\n  void RequiredPortRightCarInBlindSpotReceive(ara::com::SamplePtr< proxy::events::\n    RightCarInBlindSpot::SampleType const > elementPtr);\n};\n\n//-\n//  The generated code includes comments that allow you to trace directly\n//  back to the appropriate location in the model.  The basic format\n//  is <system>/block_name, where system is the system number (uniquely\n//  assigned by Simulink) and block_name is the name of the block.\n//\n//  Use the MATLAB hilite_system command to trace the generated code back\n//  to the model.  For example,\n//\n//  hilite_system('<S3>')    - opens system 3\n//  hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\n//\n//  Here is the system hierarchy for this model\n//\n//  '<Root>' : 'LaneGuidance'\n//  '<S1>'   : 'LaneGuidance/LaneGuidanceAlgorithm'\n//  '<S2>'   : 'LaneGuidance/LaneGuidanceAlgorithm/IfActionSS'\n//  '<S3>'   : 'LaneGuidance/LaneGuidanceAlgorithm/IfActionSS1'\n//  '<S4>'   : 'LaneGuidance/LaneGuidanceAlgorithm/IfActionSS2'\n//  '<S5>'   : 'LaneGuidance/LaneGuidanceAlgorithm/IfActionSS3'\n//  '<S6>'   : 'LaneGuidance/LaneGuidanceAlgorithm/IfActionSS4'\n//  '<S7>'   : 'LaneGuidance/LaneGuidanceAlgorithm/IfActionSS5'\n\n#endif                                 // RTW_HEADER_LaneGuidance_h_\n"},{"name":"LaneGuidance_private.h","type":"header","group":"model","path":"/home/dahyun/Documents/MATLAB/Examples/R2023b/autosarblockset/CreateAndConfigureAUTOSARAdaptiveSoftwareComponentExample/LaneGuidance_autosar_adaptive","tag":"","groupDisplay":"Model files","code":"//\n//  LaneGuidance_private.h\n//\n//  Academic License - for use in teaching, academic research, and meeting\n//  course requirements at degree granting institutions only.  Not for\n//  government, commercial, or other organizational use.\n//\n//  Code generation for model \"LaneGuidance\".\n//\n//  Model version              : 9.0\n//  Simulink Coder version : 23.2 (R2023b) 01-Aug-2023\n//  C++ source code generated on : Wed Jan 24 16:40:53 2024\n//\n//  Target selection: autosar_adaptive.tlc\n//  Embedded hardware selection: Intel->x86-64 (Linux 64)\n//  Code generation objectives: Unspecified\n//  Validation result: Not run\n\n\n#ifndef RTW_HEADER_LaneGuidance_private_h_\n#define RTW_HEADER_LaneGuidance_private_h_\n#include <stdbool.h>\n#include <stdint.h>\n#include \"complex_types.h\"\n#include \"LaneGuidance_types.h\"\n#endif                                 // RTW_HEADER_LaneGuidance_private_h_\n"},{"name":"LaneGuidance_types.h","type":"header","group":"model","path":"/home/dahyun/Documents/MATLAB/Examples/R2023b/autosarblockset/CreateAndConfigureAUTOSARAdaptiveSoftwareComponentExample/LaneGuidance_autosar_adaptive","tag":"","groupDisplay":"Model files","code":"//\n//  LaneGuidance_types.h\n//\n//  Academic License - for use in teaching, academic research, and meeting\n//  course requirements at degree granting institutions only.  Not for\n//  government, commercial, or other organizational use.\n//\n//  Code generation for model \"LaneGuidance\".\n//\n//  Model version              : 9.0\n//  Simulink Coder version : 23.2 (R2023b) 01-Aug-2023\n//  C++ source code generated on : Wed Jan 24 16:40:53 2024\n//\n//  Target selection: autosar_adaptive.tlc\n//  Embedded hardware selection: Intel->x86-64 (Linux 64)\n//  Code generation objectives: Unspecified\n//  Validation result: Not run\n\n\n#ifndef RTW_HEADER_LaneGuidance_types_h_\n#define RTW_HEADER_LaneGuidance_types_h_\n#endif                                 // RTW_HEADER_LaneGuidance_types_h_\n"},{"name":"complex_types.h","type":"header","group":"sharedutility","path":"/home/dahyun/Documents/MATLAB/Examples/R2023b/autosarblockset/CreateAndConfigureAUTOSARAdaptiveSoftwareComponentExample/slprj/autosar_adaptive/_sharedutils","tag":"","groupDisplay":"Shared files","code":"//\n//  complex_types.h\n//\n//  Academic License - for use in teaching, academic research, and meeting\n//  course requirements at degree granting institutions only.  Not for\n//  government, commercial, or other organizational use.\n//\n//  Code generation for model \"LaneGuidance\".\n//\n//  Model version              : 9.0\n//  Simulink Coder version : 23.2 (R2023b) 01-Aug-2023\n//  C++ source code generated on : Wed Jan 24 16:40:53 2024\n\n\n#ifndef COMPLEX_TYPES_H\n#define COMPLEX_TYPES_H\n#include <stdint.h>\n\n//===========================================================================*\n//  Complex number type definitions                                           *\n// ===========================================================================\n#define CREAL_T\n\ntypedef struct {\n  float re;\n  float im;\n} creal32_T;\n\ntypedef struct {\n  double re;\n  double im;\n} creal_T;\n\ntypedef creal_T creal64_T;\n\n#define CINT8_T\n\ntypedef struct {\n  int8_t re;\n  int8_t im;\n} cint8_T;\n\n#define CUINT8_T\n\ntypedef struct {\n  uint8_t re;\n  uint8_t im;\n} cuint8_T;\n\n#define CINT16_T\n\ntypedef struct {\n  int16_t re;\n  int16_t im;\n} cint16_T;\n\n#define CUINT16_T\n\ntypedef struct {\n  uint16_t re;\n  uint16_t im;\n} cuint16_T;\n\n#define CINT32_T\n\ntypedef struct {\n  int32_t re;\n  int32_t im;\n} cint32_T;\n\n#define CUINT32_T\n\ntypedef struct {\n  uint32_t re;\n  uint32_t im;\n} cuint32_T;\n\n#define CINT64_T\n\ntypedef struct {\n  int64_t re;\n  int64_t im;\n} cint64_T;\n\n#define CUINT64_T\n\ntypedef struct {\n  uint64_t re;\n  uint64_t im;\n} cuint64_T;\n\n#endif                                 // COMPLEX_TYPES_H\n"},{"name":"LaneGuidance_ExecutionManifest.arxml","type":"other","group":"interface","path":"/home/dahyun/Documents/MATLAB/Examples/R2023b/autosarblockset/CreateAndConfigureAUTOSARAdaptiveSoftwareComponentExample/LaneGuidance_autosar_adaptive","tag":"arxml","groupDisplay":"Interface files","code":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!--\nAuto generated XML Component Description for model LaneGuidance\nModel version                : 9.0\nSimulink Coder version       : Simulink Coder 23.2 (R2023b) 01-Aug-2023\nXML source code generated on : Wed Jan 24 16:42:07 2024\nModel Checksum               : 3558035547 2812919 2844783055 1948640339\n-->\n<AUTOSAR xmlns=\"http://autosar.org/schema/r4.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://autosar.org/schema/r4.0 AUTOSAR_00050.xsd\">\n    <AR-PACKAGES>\n        <AR-PACKAGE>\n            <SHORT-NAME>LaneGuidance_Executable</SHORT-NAME>\n            <ELEMENTS>\n                <EXECUTABLE UUID=\"a98f3702-9c00-5a07-5afd-46a59bd23d25\">\n                    <SHORT-NAME>LaneGuidance</SHORT-NAME>\n                    <BUILD-TYPE>BUILD-TYPE-DEBUG</BUILD-TYPE>\n                    <LOGGING-BEHAVIOR>USES-LOGGING</LOGGING-BEHAVIOR>\n                    <ROOT-SW-COMPONENT-PROTOTYPE UUID=\"b2add47c-1efb-5800-aeb1-87cd30eec743\">\n                        <SHORT-NAME>LaneGuidance_RootSwComponentPrototype</SHORT-NAME>\n                        <APPLICATION-TYPE-TREF DEST=\"ADAPTIVE-APPLICATION-SW-COMPONENT-TYPE\">/Components/LaneGuidance</APPLICATION-TYPE-TREF>\n                    </ROOT-SW-COMPONENT-PROTOTYPE>\n                </EXECUTABLE>\n            </ELEMENTS>\n        </AR-PACKAGE>\n        <AR-PACKAGE>\n            <SHORT-NAME>LaneGuidance_FunctionGroupSet</SHORT-NAME>\n            <ELEMENTS>\n                <FUNCTION-GROUP-SET UUID=\"7e62616b-f11c-5080-1235-2d5fd9e89891\">\n                    <SHORT-NAME>DefaultFunctionGroupSet</SHORT-NAME>\n                    <FUNCTION-GROUPS>\n                        <MODE-DECLARATION-GROUP-PROTOTYPE UUID=\"f7a62472-3fbb-5c35-9775-401857cc8685\">\n                            <SHORT-NAME>DefaultFunctionGroupSet_ModeDeclarationGroupElement</SHORT-NAME>\n                            <SW-CALIBRATION-ACCESS>READ-ONLY</SW-CALIBRATION-ACCESS>\n                            <TYPE-TREF DEST=\"MODE-DECLARATION-GROUP\">/MachineStates/MachineFG</TYPE-TREF>\n                        </MODE-DECLARATION-GROUP-PROTOTYPE>\n                    </FUNCTION-GROUPS>\n                </FUNCTION-GROUP-SET>\n            </ELEMENTS>\n        </AR-PACKAGE>\n        <AR-PACKAGE>\n            <SHORT-NAME>LaneGuidance_ProcessDesigns</SHORT-NAME>\n            <ELEMENTS>\n                <PROCESS-DESIGN UUID=\"c07ec90c-642e-5d95-cd72-5bdd592eebf0\">\n                    <SHORT-NAME>DefaultProcessDesign</SHORT-NAME>\n                    <EXECUTABLE-REF DEST=\"EXECUTABLE\">/LaneGuidance_Executable/LaneGuidance</EXECUTABLE-REF>\n                </PROCESS-DESIGN>\n            </ELEMENTS>\n        </AR-PACKAGE>\n        <AR-PACKAGE>\n            <SHORT-NAME>LaneGuidance_ProcessToMachineMappingSet</SHORT-NAME>\n            <ELEMENTS>\n                <PROCESS-TO-MACHINE-MAPPING-SET UUID=\"5a1b72b0-62be-5b4d-5e3b-e78cff7f34eb\">\n                    <SHORT-NAME>ProcessToMachineMappingSet</SHORT-NAME>\n                    <PROCESS-TO-MACHINE-MAPPINGS>\n                        <PROCESS-TO-MACHINE-MAPPING UUID=\"33ead97a-5b54-52a1-6762-9164689b3121\">\n                            <SHORT-NAME>DefaultMapping</SHORT-NAME>\n                            <MACHINE-REF DEST=\"MACHINE\">/Machines/Host</MACHINE-REF>\n                            <PROCESS-REF DEST=\"PROCESS\">/LaneGuidance_Processes/DefaultInstance</PROCESS-REF>\n                        </PROCESS-TO-MACHINE-MAPPING>\n                    </PROCESS-TO-MACHINE-MAPPINGS>\n                </PROCESS-TO-MACHINE-MAPPING-SET>\n            </ELEMENTS>\n        </AR-PACKAGE>\n        <AR-PACKAGE>\n            <SHORT-NAME>LaneGuidance_Processes</SHORT-NAME>\n            <ELEMENTS>\n                <PROCESS UUID=\"dc1d40a3-0ba1-5b38-1f6f-b6b1da7276de\">\n                    <SHORT-NAME>DefaultInstance</SHORT-NAME>\n                    <DESIGN-REF DEST=\"PROCESS-DESIGN\">/LaneGuidance_ProcessDesigns/DefaultProcessDesign</DESIGN-REF>\n                    <EXECUTABLE-REF DEST=\"EXECUTABLE\">/LaneGuidance_Executable/LaneGuidance</EXECUTABLE-REF>\n                    <PROCESS-STATE-MACHINE UUID=\"1d46b03a-53a6-54c2-9a22-e0f5c48649f7\">\n                        <SHORT-NAME>ProcessStateMachine_ModeDeclarationGroupElement</SHORT-NAME>\n                        <SW-CALIBRATION-ACCESS>READ-ONLY</SW-CALIBRATION-ACCESS>\n                        <TYPE-TREF DEST=\"MODE-DECLARATION-GROUP\">/ModeDeclarationGroups/ProcessStateMachine</TYPE-TREF>\n                    </PROCESS-STATE-MACHINE>\n                    <STATE-DEPENDENT-STARTUP-CONFIGS>\n                        <STATE-DEPENDENT-STARTUP-CONFIG>\n                            <FUNCTION-GROUP-STATE-IREFS>\n                                <FUNCTION-GROUP-STATE-IREF>\n                                    <CONTEXT-MODE-DECLARATION-GROUP-PROTOTYPE-REF DEST=\"MODE-DECLARATION-GROUP-PROTOTYPE\">/LaneGuidance_FunctionGroupSet/DefaultFunctionGroupSet/DefaultFunctionGroupSet_ModeDeclarationGroupElement</CONTEXT-MODE-DECLARATION-GROUP-PROTOTYPE-REF>\n                                    <TARGET-MODE-DECLARATION-REF DEST=\"MODE-DECLARATION\">/MachineStates/MachineFG/Running</TARGET-MODE-DECLARATION-REF>\n                                </FUNCTION-GROUP-STATE-IREF>\n                            </FUNCTION-GROUP-STATE-IREFS>\n                            <RESOURCE-GROUP-REF DEST=\"RESOURCE-GROUP\">/Machines/Host/HostOsInstantiation/DefaultResourceGroup</RESOURCE-GROUP-REF>\n                            <STARTUP-CONFIG-REF DEST=\"STARTUP-CONFIG\">/LaneGuidance_StartupConfigs/StartupConfigRR</STARTUP-CONFIG-REF>\n                        </STATE-DEPENDENT-STARTUP-CONFIG>\n                    </STATE-DEPENDENT-STARTUP-CONFIGS>\n                </PROCESS>\n            </ELEMENTS>\n        </AR-PACKAGE>\n        <AR-PACKAGE>\n            <SHORT-NAME>LaneGuidance_StartupConfigs</SHORT-NAME>\n            <ELEMENTS>\n                <STARTUP-CONFIG UUID=\"066c7501-30b0-5027-c255-cdbefb02caff\">\n                    <SHORT-NAME>StartupConfigRR</SHORT-NAME>\n                    <SCHEDULING-POLICY>SCHEDULING-POLICY-ROUND-ROBIN</SCHEDULING-POLICY>\n                    <SCHEDULING-PRIORITY>32</SCHEDULING-PRIORITY>\n                </STARTUP-CONFIG>\n                <STARTUP-CONFIG UUID=\"2ef47936-be78-57b1-3f49-f7e1d4874c27\">\n                    <SHORT-NAME>StartupConfigFifo</SHORT-NAME>\n                    <SCHEDULING-POLICY>SCHEDULING-POLICY-FIFO</SCHEDULING-POLICY>\n                    <SCHEDULING-PRIORITY>32</SCHEDULING-PRIORITY>\n                </STARTUP-CONFIG>\n                <STARTUP-CONFIG UUID=\"c88fad25-ef80-5f76-b704-32332d1d4c33\">\n                    <SHORT-NAME>StartupConfigOther</SHORT-NAME>\n                    <SCHEDULING-POLICY>SCHEDULING-POLICY-OTHER</SCHEDULING-POLICY>\n                    <SCHEDULING-PRIORITY>32</SCHEDULING-PRIORITY>\n                </STARTUP-CONFIG>\n            </ELEMENTS>\n        </AR-PACKAGE>\n        <AR-PACKAGE>\n            <SHORT-NAME>ModeDeclarationGroups</SHORT-NAME>\n            <ELEMENTS>\n                <MODE-DECLARATION-GROUP>\n                    <SHORT-NAME>ProcessStateMachine</SHORT-NAME>\n                    <INITIAL-MODE-REF DEST=\"MODE-DECLARATION\">/ModeDeclarationGroups/ProcessStateMachine/Idle</INITIAL-MODE-REF>\n                    <MODE-DECLARATIONS>\n                        <MODE-DECLARATION UUID=\"461ba94d-19ef-5270-ac25-f352c2d16e8a\">\n                            <SHORT-NAME>Idle</SHORT-NAME>\n                            <VALUE>1</VALUE>\n                        </MODE-DECLARATION>\n                        <MODE-DECLARATION UUID=\"25f8790a-08f2-57ac-7d7e-e31f3b856466\">\n                            <SHORT-NAME>Starting</SHORT-NAME>\n                            <VALUE>2</VALUE>\n                        </MODE-DECLARATION>\n                        <MODE-DECLARATION UUID=\"acf9c738-7092-5e4d-be66-8262fec923de\">\n                            <SHORT-NAME>Running</SHORT-NAME>\n                            <VALUE>3</VALUE>\n                        </MODE-DECLARATION>\n                        <MODE-DECLARATION UUID=\"1512bb28-fbe7-50b0-66b5-ba728b83bcc4\">\n                            <SHORT-NAME>Terminating</SHORT-NAME>\n                            <VALUE>4</VALUE>\n                        </MODE-DECLARATION>\n                        <MODE-DECLARATION UUID=\"43712d9f-780b-51e7-6bc3-a36cc00b1def\">\n                            <SHORT-NAME>Terminated</SHORT-NAME>\n                            <VALUE>5</VALUE>\n                        </MODE-DECLARATION>\n                    </MODE-DECLARATIONS>\n                </MODE-DECLARATION-GROUP>\n            </ELEMENTS>\n        </AR-PACKAGE>\n    </AR-PACKAGES>\n</AUTOSAR>\n"},{"name":"LaneGuidance_ServiceInstanceManifest.arxml","type":"other","group":"interface","path":"/home/dahyun/Documents/MATLAB/Examples/R2023b/autosarblockset/CreateAndConfigureAUTOSARAdaptiveSoftwareComponentExample/LaneGuidance_autosar_adaptive","tag":"arxml","groupDisplay":"Interface files","code":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!--\nAuto generated XML Component Description for model LaneGuidance\nModel version                : 9.0\nSimulink Coder version       : Simulink Coder 23.2 (R2023b) 01-Aug-2023\nXML source code generated on : Wed Jan 24 16:42:07 2024\nModel Checksum               : 3558035547 2812919 2844783055 1948640339\n-->\n<AUTOSAR xmlns=\"http://autosar.org/schema/r4.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://autosar.org/schema/r4.0 AUTOSAR_00050.xsd\">\n    <AR-PACKAGES>\n        <AR-PACKAGE>\n            <SHORT-NAME>LaneGuidance_CommunicationCluster</SHORT-NAME>\n            <ELEMENTS>\n                <ETHERNET-CLUSTER UUID=\"b196d153-f5eb-5b28-451f-741d77e59381\">\n                    <SHORT-NAME>ComCluster</SHORT-NAME>\n                    <ETHERNET-CLUSTER-VARIANTS>\n                        <ETHERNET-CLUSTER-CONDITIONAL>\n                            <PHYSICAL-CHANNELS>\n                                <ETHERNET-PHYSICAL-CHANNEL UUID=\"d0061696-d001-5e1a-9bc5-d667f271a291\">\n                                    <SHORT-NAME>PhysicalChannel</SHORT-NAME>\n                                    <NETWORK-ENDPOINTS>\n                                        <NETWORK-ENDPOINT UUID=\"0a54433f-9976-564a-c460-68f473a58bfe\">\n                                            <SHORT-NAME>NetworkEndpoint</SHORT-NAME>\n                                            <NETWORK-ENDPOINT-ADDRESSES>\n                                                <IPV-4-CONFIGURATION>\n                                                    <IPV-4-ADDRESS>127.0.0.1</IPV-4-ADDRESS>\n                                                </IPV-4-CONFIGURATION>\n                                            </NETWORK-ENDPOINT-ADDRESSES>\n                                        </NETWORK-ENDPOINT>\n                                    </NETWORK-ENDPOINTS>\n                                </ETHERNET-PHYSICAL-CHANNEL>\n                            </PHYSICAL-CHANNELS>\n                        </ETHERNET-CLUSTER-CONDITIONAL>\n                    </ETHERNET-CLUSTER-VARIANTS>\n                </ETHERNET-CLUSTER>\n            </ELEMENTS>\n        </AR-PACKAGE>\n        <AR-PACKAGE>\n            <SHORT-NAME>LaneGuidance_Deployments</SHORT-NAME>\n            <ELEMENTS>\n                <DDS-SERVICE-INTERFACE-DEPLOYMENT UUID=\"15495758-305f-5851-88af-12c8df8d185a\">\n                    <SHORT-NAME>DdsDeployment_RequiredPort</SHORT-NAME>\n                    <EVENT-DEPLOYMENTS>\n                        <DDS-EVENT-DEPLOYMENT UUID=\"671a259e-a68e-53e3-b7ab-d0ca8fae3f9e\">\n                            <SHORT-NAME>Deployment_LeftLaneDistance</SHORT-NAME>\n                            <EVENT-REF DEST=\"VARIABLE-DATA-PROTOTYPE\">/Interfaces/RequiredInterface/LeftLaneDistance</EVENT-REF>\n                            <TOPIC-NAME>LeftLaneDistance</TOPIC-NAME>\n                            <TRANSPORT-PROTOCOLS>\n                                <TRANSPORT-PROTOCOL>TCP</TRANSPORT-PROTOCOL>\n                            </TRANSPORT-PROTOCOLS>\n                        </DDS-EVENT-DEPLOYMENT>\n                        <DDS-EVENT-DEPLOYMENT UUID=\"3c46d334-32c0-5713-5d0e-15a041444a52\">\n                            <SHORT-NAME>Deployment_LeftTurnIndicator</SHORT-NAME>\n                            <EVENT-REF DEST=\"VARIABLE-DATA-PROTOTYPE\">/Interfaces/RequiredInterface/LeftTurnIndicator</EVENT-REF>\n                            <TOPIC-NAME>LeftTurnIndicator</TOPIC-NAME>\n                            <TRANSPORT-PROTOCOLS>\n                                <TRANSPORT-PROTOCOL>TCP</TRANSPORT-PROTOCOL>\n                            </TRANSPORT-PROTOCOLS>\n                        </DDS-EVENT-DEPLOYMENT>\n                        <DDS-EVENT-DEPLOYMENT UUID=\"a1c6f56f-4462-520a-3e2b-7b413f7cbddd\">\n                            <SHORT-NAME>Deployment_RightLaneDistance</SHORT-NAME>\n                            <EVENT-REF DEST=\"VARIABLE-DATA-PROTOTYPE\">/Interfaces/RequiredInterface/RightLaneDistance</EVENT-REF>\n                            <TOPIC-NAME>RightLaneDistance</TOPIC-NAME>\n                            <TRANSPORT-PROTOCOLS>\n                                <TRANSPORT-PROTOCOL>TCP</TRANSPORT-PROTOCOL>\n                            </TRANSPORT-PROTOCOLS>\n                        </DDS-EVENT-DEPLOYMENT>\n                        <DDS-EVENT-DEPLOYMENT UUID=\"a9c32534-0d38-5256-bf8c-03e724571c61\">\n                            <SHORT-NAME>Deployment_RightTurnIndicator</SHORT-NAME>\n                            <EVENT-REF DEST=\"VARIABLE-DATA-PROTOTYPE\">/Interfaces/RequiredInterface/RightTurnIndicator</EVENT-REF>\n                            <TOPIC-NAME>RightTurnIndicator</TOPIC-NAME>\n                            <TRANSPORT-PROTOCOLS>\n                                <TRANSPORT-PROTOCOL>TCP</TRANSPORT-PROTOCOL>\n                            </TRANSPORT-PROTOCOLS>\n                        </DDS-EVENT-DEPLOYMENT>\n                        <DDS-EVENT-DEPLOYMENT UUID=\"3d062ff0-914e-52ff-96f1-e19ff9dd0559\">\n                            <SHORT-NAME>Deployment_LeftCarInBlindSpot</SHORT-NAME>\n                            <EVENT-REF DEST=\"VARIABLE-DATA-PROTOTYPE\">/Interfaces/RequiredInterface/LeftCarInBlindSpot</EVENT-REF>\n                            <TOPIC-NAME>LeftCarInBlindSpot</TOPIC-NAME>\n                            <TRANSPORT-PROTOCOLS>\n                                <TRANSPORT-PROTOCOL>TCP</TRANSPORT-PROTOCOL>\n                            </TRANSPORT-PROTOCOLS>\n                        </DDS-EVENT-DEPLOYMENT>\n                        <DDS-EVENT-DEPLOYMENT UUID=\"d1709657-f73d-50a9-1376-bee4c73e53fc\">\n                            <SHORT-NAME>Deployment_RightCarInBlindSpot</SHORT-NAME>\n                            <EVENT-REF DEST=\"VARIABLE-DATA-PROTOTYPE\">/Interfaces/RequiredInterface/RightCarInBlindSpot</EVENT-REF>\n                            <TOPIC-NAME>RightCarInBlindSpot</TOPIC-NAME>\n                            <TRANSPORT-PROTOCOLS>\n                                <TRANSPORT-PROTOCOL>TCP</TRANSPORT-PROTOCOL>\n                            </TRANSPORT-PROTOCOLS>\n                        </DDS-EVENT-DEPLOYMENT>\n                    </EVENT-DEPLOYMENTS>\n                    <TRANSPORT-PROTOCOLS>\n                        <TRANSPORT-PROTOCOL>TCP</TRANSPORT-PROTOCOL>\n                    </TRANSPORT-PROTOCOLS>\n                </DDS-SERVICE-INTERFACE-DEPLOYMENT>\n                <DDS-SERVICE-INTERFACE-DEPLOYMENT UUID=\"57784737-ad16-5167-6ccd-224095e972bb\">\n                    <SHORT-NAME>DdsDeployment_ProvidedPort</SHORT-NAME>\n                    <EVENT-DEPLOYMENTS>\n                        <DDS-EVENT-DEPLOYMENT UUID=\"bde74af0-002f-5f95-6d57-8b85c059f04b\">\n                            <SHORT-NAME>Deployment_LeftHazardIndicator</SHORT-NAME>\n                            <EVENT-REF DEST=\"VARIABLE-DATA-PROTOTYPE\">/Interfaces/ProvidedInterface/LeftHazardIndicator</EVENT-REF>\n                            <TOPIC-NAME>LeftHazardIndicator</TOPIC-NAME>\n                            <TRANSPORT-PROTOCOLS>\n                                <TRANSPORT-PROTOCOL>TCP</TRANSPORT-PROTOCOL>\n                            </TRANSPORT-PROTOCOLS>\n                        </DDS-EVENT-DEPLOYMENT>\n                        <DDS-EVENT-DEPLOYMENT UUID=\"5bbdc62c-6be9-556c-7df7-06853a169a0f\">\n                            <SHORT-NAME>Deployment_RightHazardIndicator</SHORT-NAME>\n                            <EVENT-REF DEST=\"VARIABLE-DATA-PROTOTYPE\">/Interfaces/ProvidedInterface/RightHazardIndicator</EVENT-REF>\n                            <TOPIC-NAME>RightHazardIndicator</TOPIC-NAME>\n                            <TRANSPORT-PROTOCOLS>\n                                <TRANSPORT-PROTOCOL>TCP</TRANSPORT-PROTOCOL>\n                            </TRANSPORT-PROTOCOLS>\n                        </DDS-EVENT-DEPLOYMENT>\n                    </EVENT-DEPLOYMENTS>\n                    <TRANSPORT-PROTOCOLS>\n                        <TRANSPORT-PROTOCOL>TCP</TRANSPORT-PROTOCOL>\n                    </TRANSPORT-PROTOCOLS>\n                </DDS-SERVICE-INTERFACE-DEPLOYMENT>\n            </ELEMENTS>\n        </AR-PACKAGE>\n        <AR-PACKAGE>\n            <SHORT-NAME>LaneGuidance_MachineDesign</SHORT-NAME>\n            <ELEMENTS>\n                <MACHINE-DESIGN UUID=\"3ddd83fd-d13e-5631-8d07-05580f7fae32\">\n                    <SHORT-NAME>MachineDesign</SHORT-NAME>\n                    <COMMUNICATION-CONNECTORS>\n                        <ETHERNET-COMMUNICATION-CONNECTOR UUID=\"a46a61c4-ed7f-58ff-fcd6-d1fc780263e8\">\n                            <SHORT-NAME>CommunicationConnector</SHORT-NAME>\n                            <UNICAST-NETWORK-ENDPOINT-REF DEST=\"NETWORK-ENDPOINT\">/LaneGuidance_CommunicationCluster/ComCluster/PhysicalChannel/NetworkEndpoint</UNICAST-NETWORK-ENDPOINT-REF>\n                        </ETHERNET-COMMUNICATION-CONNECTOR>\n                    </COMMUNICATION-CONNECTORS>\n                </MACHINE-DESIGN>\n            </ELEMENTS>\n        </AR-PACKAGE>\n        <AR-PACKAGE>\n            <SHORT-NAME>LaneGuidance_ServiceInstToMachineMap</SHORT-NAME>\n            <ELEMENTS>\n                <DDS-SERVICE-INSTANCE-TO-MACHINE-MAPPING UUID=\"e8d8c507-4222-5637-48e5-f08888db3843\">\n                    <SHORT-NAME>DdsServiceInstToMachineMap_DdsSI_RequiredPort</SHORT-NAME>\n                    <COMMUNICATION-CONNECTOR-REF DEST=\"COMMUNICATION-CONNECTOR\">/LaneGuidance_MachineDesign/MachineDesign/CommunicationConnector</COMMUNICATION-CONNECTOR-REF>\n                    <SERVICE-INSTANCE-REFS>\n                        <SERVICE-INSTANCE-REF DEST=\"DDS-REQUIRED-SERVICE-INSTANCE\">/LaneGuidance_ServiceInstances/DdsSI_RequiredPort</SERVICE-INSTANCE-REF>\n                    </SERVICE-INSTANCE-REFS>\n                </DDS-SERVICE-INSTANCE-TO-MACHINE-MAPPING>\n                <DDS-SERVICE-INSTANCE-TO-MACHINE-MAPPING UUID=\"4401283d-dffd-5790-3ac0-9d780ede0c4e\">\n                    <SHORT-NAME>DdsServiceInstToMachineMap_DdsSI_ProvidedPort</SHORT-NAME>\n                    <COMMUNICATION-CONNECTOR-REF DEST=\"COMMUNICATION-CONNECTOR\">/LaneGuidance_MachineDesign/MachineDesign/CommunicationConnector</COMMUNICATION-CONNECTOR-REF>\n                    <SERVICE-INSTANCE-REFS>\n                        <SERVICE-INSTANCE-REF DEST=\"DDS-PROVIDED-SERVICE-INSTANCE\">/LaneGuidance_ServiceInstances/DdsSI_ProvidedPort</SERVICE-INSTANCE-REF>\n                    </SERVICE-INSTANCE-REFS>\n                </DDS-SERVICE-INSTANCE-TO-MACHINE-MAPPING>\n            </ELEMENTS>\n        </AR-PACKAGE>\n        <AR-PACKAGE>\n            <SHORT-NAME>LaneGuidance_ServiceInstanceToPortMappings</SHORT-NAME>\n            <ELEMENTS>\n                <SERVICE-INSTANCE-TO-PORT-PROTOTYPE-MAPPING UUID=\"397a87b9-e22e-55e7-efac-d372301db569\">\n                    <SHORT-NAME>Mapping_RequiredPort</SHORT-NAME>\n                    <PORT-PROTOTYPE-IREF>\n                        <CONTEXT-COMPONENT-PROTOTYPE-REF DEST=\"SW-COMPONENT-PROTOTYPE\">/Components/LaneGuidance</CONTEXT-COMPONENT-PROTOTYPE-REF>\n                        <TARGET-PORT-PROTOTYPE-REF DEST=\"R-PORT-PROTOTYPE\">/Components/LaneGuidance/RequiredPort</TARGET-PORT-PROTOTYPE-REF>\n                    </PORT-PROTOTYPE-IREF>\n                    <PROCESS-DESIGN-REF DEST=\"PROCESS-DESIGN\">/LaneGuidance_ProcessDesigns/DefaultProcessDesign</PROCESS-DESIGN-REF>\n                    <SERVICE-INSTANCE-REF DEST=\"DDS-REQUIRED-SERVICE-INSTANCE\">/LaneGuidance_ServiceInstances/DdsSI_RequiredPort</SERVICE-INSTANCE-REF>\n                </SERVICE-INSTANCE-TO-PORT-PROTOTYPE-MAPPING>\n                <SERVICE-INSTANCE-TO-PORT-PROTOTYPE-MAPPING UUID=\"48d8920f-f951-5713-d705-720575ea2655\">\n                    <SHORT-NAME>Mapping_ProvidedPort</SHORT-NAME>\n                    <PORT-PROTOTYPE-IREF>\n                        <CONTEXT-COMPONENT-PROTOTYPE-REF DEST=\"SW-COMPONENT-PROTOTYPE\">/Components/LaneGuidance</CONTEXT-COMPONENT-PROTOTYPE-REF>\n                        <TARGET-PORT-PROTOTYPE-REF DEST=\"P-PORT-PROTOTYPE\">/Components/LaneGuidance/ProvidedPort</TARGET-PORT-PROTOTYPE-REF>\n                    </PORT-PROTOTYPE-IREF>\n                    <PROCESS-DESIGN-REF DEST=\"PROCESS-DESIGN\">/LaneGuidance_ProcessDesigns/DefaultProcessDesign</PROCESS-DESIGN-REF>\n                    <SERVICE-INSTANCE-REF DEST=\"DDS-PROVIDED-SERVICE-INSTANCE\">/LaneGuidance_ServiceInstances/DdsSI_ProvidedPort</SERVICE-INSTANCE-REF>\n                </SERVICE-INSTANCE-TO-PORT-PROTOTYPE-MAPPING>\n            </ELEMENTS>\n        </AR-PACKAGE>\n        <AR-PACKAGE>\n            <SHORT-NAME>LaneGuidance_ServiceInstances</SHORT-NAME>\n            <ELEMENTS>\n                <DDS-REQUIRED-SERVICE-INSTANCE UUID=\"03ba2f5a-5eb8-5e36-411d-f919b8ceca25\">\n                    <SHORT-NAME>DdsSI_RequiredPort</SHORT-NAME>\n                    <SERVICE-INTERFACE-DEPLOYMENT-REF DEST=\"DDS-SERVICE-INTERFACE-DEPLOYMENT\">/LaneGuidance_Deployments/DdsDeployment_RequiredPort</SERVICE-INTERFACE-DEPLOYMENT-REF>\n                    <DOMAIN-ID>0</DOMAIN-ID>\n                    <EVENT-QOS-PROPSS>\n                        <DDS-EVENT-QOS-PROPS>\n                            <QOS-PROFILE>RELIABLE</QOS-PROFILE>\n                            <EVENT-REF DEST=\"DDS-EVENT-DEPLOYMENT\">/LaneGuidance_Deployments/DdsDeployment_RequiredPort/Deployment_LeftLaneDistance</EVENT-REF>\n                        </DDS-EVENT-QOS-PROPS>\n                        <DDS-EVENT-QOS-PROPS>\n                            <QOS-PROFILE>RELIABLE</QOS-PROFILE>\n                            <EVENT-REF DEST=\"DDS-EVENT-DEPLOYMENT\">/LaneGuidance_Deployments/DdsDeployment_RequiredPort/Deployment_LeftTurnIndicator</EVENT-REF>\n                        </DDS-EVENT-QOS-PROPS>\n                        <DDS-EVENT-QOS-PROPS>\n                            <QOS-PROFILE>RELIABLE</QOS-PROFILE>\n                            <EVENT-REF DEST=\"DDS-EVENT-DEPLOYMENT\">/LaneGuidance_Deployments/DdsDeployment_RequiredPort/Deployment_RightLaneDistance</EVENT-REF>\n                        </DDS-EVENT-QOS-PROPS>\n                        <DDS-EVENT-QOS-PROPS>\n                            <QOS-PROFILE>RELIABLE</QOS-PROFILE>\n                            <EVENT-REF DEST=\"DDS-EVENT-DEPLOYMENT\">/LaneGuidance_Deployments/DdsDeployment_RequiredPort/Deployment_RightTurnIndicator</EVENT-REF>\n                        </DDS-EVENT-QOS-PROPS>\n                        <DDS-EVENT-QOS-PROPS>\n                            <QOS-PROFILE>RELIABLE</QOS-PROFILE>\n                            <EVENT-REF DEST=\"DDS-EVENT-DEPLOYMENT\">/LaneGuidance_Deployments/DdsDeployment_RequiredPort/Deployment_LeftCarInBlindSpot</EVENT-REF>\n                        </DDS-EVENT-QOS-PROPS>\n                        <DDS-EVENT-QOS-PROPS>\n                            <QOS-PROFILE>RELIABLE</QOS-PROFILE>\n                            <EVENT-REF DEST=\"DDS-EVENT-DEPLOYMENT\">/LaneGuidance_Deployments/DdsDeployment_RequiredPort/Deployment_RightCarInBlindSpot</EVENT-REF>\n                        </DDS-EVENT-QOS-PROPS>\n                    </EVENT-QOS-PROPSS>\n                    <REQUIRED-SERVICE-INSTANCE-ID>1</REQUIRED-SERVICE-INSTANCE-ID>\n                </DDS-REQUIRED-SERVICE-INSTANCE>\n                <DDS-PROVIDED-SERVICE-INSTANCE UUID=\"2234ce22-0dcb-55a3-24ff-97d856d9058f\">\n                    <SHORT-NAME>DdsSI_ProvidedPort</SHORT-NAME>\n                    <SERVICE-INTERFACE-DEPLOYMENT-REF DEST=\"DDS-SERVICE-INTERFACE-DEPLOYMENT\">/LaneGuidance_Deployments/DdsDeployment_ProvidedPort</SERVICE-INTERFACE-DEPLOYMENT-REF>\n                    <DOMAIN-ID>0</DOMAIN-ID>\n                    <EVENT-QOS-PROPSS>\n                        <DDS-EVENT-QOS-PROPS>\n                            <QOS-PROFILE>RELIABLE</QOS-PROFILE>\n                            <EVENT-REF DEST=\"DDS-EVENT-DEPLOYMENT\">/LaneGuidance_Deployments/DdsDeployment_ProvidedPort/Deployment_LeftHazardIndicator</EVENT-REF>\n                        </DDS-EVENT-QOS-PROPS>\n                        <DDS-EVENT-QOS-PROPS>\n                            <QOS-PROFILE>RELIABLE</QOS-PROFILE>\n                            <EVENT-REF DEST=\"DDS-EVENT-DEPLOYMENT\">/LaneGuidance_Deployments/DdsDeployment_ProvidedPort/Deployment_RightHazardIndicator</EVENT-REF>\n                        </DDS-EVENT-QOS-PROPS>\n                    </EVENT-QOS-PROPSS>\n                    <SERVICE-INSTANCE-ID>2</SERVICE-INSTANCE-ID>\n                </DDS-PROVIDED-SERVICE-INSTANCE>\n            </ELEMENTS>\n        </AR-PACKAGE>\n    </AR-PACKAGES>\n</AUTOSAR>\n"},{"name":"LaneGuidance_component.arxml","type":"other","group":"interface","path":"/home/dahyun/Documents/MATLAB/Examples/R2023b/autosarblockset/CreateAndConfigureAUTOSARAdaptiveSoftwareComponentExample/LaneGuidance_autosar_adaptive","tag":"arxml","groupDisplay":"Interface files","code":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!--\nAuto generated XML Component Description for model LaneGuidance\nModel version                : 9.0\nSimulink Coder version       : Simulink Coder 23.2 (R2023b) 01-Aug-2023\nXML source code generated on : Wed Jan 24 16:42:07 2024\nModel Checksum               : 3558035547 2812919 2844783055 1948640339\n-->\n<AUTOSAR xmlns=\"http://autosar.org/schema/r4.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://autosar.org/schema/r4.0 AUTOSAR_00050.xsd\">\n    <AR-PACKAGES>\n        <AR-PACKAGE>\n            <SHORT-NAME>Components</SHORT-NAME>\n            <ELEMENTS>\n                <ADAPTIVE-APPLICATION-SW-COMPONENT-TYPE UUID=\"6cb6302e-1f86-573d-34bd-cb63eaf85e51\">\n                    <SHORT-NAME>LaneGuidance</SHORT-NAME>\n                    <PORTS>\n                        <R-PORT-PROTOTYPE UUID=\"594ebf1c-cd0d-551b-a868-06ea0b8af088\">\n                            <SHORT-NAME>RequiredPort</SHORT-NAME>\n                            <REQUIRED-COM-SPECS>\n                                <QUEUED-RECEIVER-COM-SPEC>\n                                    <DATA-ELEMENT-REF DEST=\"VARIABLE-DATA-PROTOTYPE\">/Interfaces/RequiredInterface/LeftLaneDistance</DATA-ELEMENT-REF>\n                                    <HANDLE-OUT-OF-RANGE>NONE</HANDLE-OUT-OF-RANGE>\n                                    <USES-END-TO-END-PROTECTION>false</USES-END-TO-END-PROTECTION>\n                                </QUEUED-RECEIVER-COM-SPEC>\n                                <QUEUED-RECEIVER-COM-SPEC>\n                                    <DATA-ELEMENT-REF DEST=\"VARIABLE-DATA-PROTOTYPE\">/Interfaces/RequiredInterface/LeftTurnIndicator</DATA-ELEMENT-REF>\n                                    <HANDLE-OUT-OF-RANGE>NONE</HANDLE-OUT-OF-RANGE>\n                                    <USES-END-TO-END-PROTECTION>false</USES-END-TO-END-PROTECTION>\n                                </QUEUED-RECEIVER-COM-SPEC>\n                                <QUEUED-RECEIVER-COM-SPEC>\n                                    <DATA-ELEMENT-REF DEST=\"VARIABLE-DATA-PROTOTYPE\">/Interfaces/RequiredInterface/RightLaneDistance</DATA-ELEMENT-REF>\n                                    <HANDLE-OUT-OF-RANGE>NONE</HANDLE-OUT-OF-RANGE>\n                                    <USES-END-TO-END-PROTECTION>false</USES-END-TO-END-PROTECTION>\n                                </QUEUED-RECEIVER-COM-SPEC>\n                                <QUEUED-RECEIVER-COM-SPEC>\n                                    <DATA-ELEMENT-REF DEST=\"VARIABLE-DATA-PROTOTYPE\">/Interfaces/RequiredInterface/RightTurnIndicator</DATA-ELEMENT-REF>\n                                    <HANDLE-OUT-OF-RANGE>NONE</HANDLE-OUT-OF-RANGE>\n                                    <USES-END-TO-END-PROTECTION>false</USES-END-TO-END-PROTECTION>\n                                </QUEUED-RECEIVER-COM-SPEC>\n                                <QUEUED-RECEIVER-COM-SPEC>\n                                    <DATA-ELEMENT-REF DEST=\"VARIABLE-DATA-PROTOTYPE\">/Interfaces/RequiredInterface/LeftCarInBlindSpot</DATA-ELEMENT-REF>\n                                    <HANDLE-OUT-OF-RANGE>NONE</HANDLE-OUT-OF-RANGE>\n                                    <USES-END-TO-END-PROTECTION>false</USES-END-TO-END-PROTECTION>\n                                </QUEUED-RECEIVER-COM-SPEC>\n                                <QUEUED-RECEIVER-COM-SPEC>\n                                    <DATA-ELEMENT-REF DEST=\"VARIABLE-DATA-PROTOTYPE\">/Interfaces/RequiredInterface/RightCarInBlindSpot</DATA-ELEMENT-REF>\n                                    <HANDLE-OUT-OF-RANGE>NONE</HANDLE-OUT-OF-RANGE>\n                                    <USES-END-TO-END-PROTECTION>false</USES-END-TO-END-PROTECTION>\n                                </QUEUED-RECEIVER-COM-SPEC>\n                            </REQUIRED-COM-SPECS>\n                            <REQUIRED-INTERFACE-TREF DEST=\"SERVICE-INTERFACE\">/Interfaces/RequiredInterface</REQUIRED-INTERFACE-TREF>\n                        </R-PORT-PROTOTYPE>\n                        <P-PORT-PROTOTYPE UUID=\"c0c117d0-0f63-5ec2-7c55-f1f929b88f91\">\n                            <SHORT-NAME>ProvidedPort</SHORT-NAME>\n                            <PROVIDED-COM-SPECS>\n                                <QUEUED-SENDER-COM-SPEC>\n                                    <DATA-ELEMENT-REF DEST=\"VARIABLE-DATA-PROTOTYPE\">/Interfaces/ProvidedInterface/LeftHazardIndicator</DATA-ELEMENT-REF>\n                                    <HANDLE-OUT-OF-RANGE>NONE</HANDLE-OUT-OF-RANGE>\n                                    <USES-END-TO-END-PROTECTION>false</USES-END-TO-END-PROTECTION>\n                                </QUEUED-SENDER-COM-SPEC>\n                                <QUEUED-SENDER-COM-SPEC>\n                                    <DATA-ELEMENT-REF DEST=\"VARIABLE-DATA-PROTOTYPE\">/Interfaces/ProvidedInterface/RightHazardIndicator</DATA-ELEMENT-REF>\n                                    <HANDLE-OUT-OF-RANGE>NONE</HANDLE-OUT-OF-RANGE>\n                                    <USES-END-TO-END-PROTECTION>false</USES-END-TO-END-PROTECTION>\n                                </QUEUED-SENDER-COM-SPEC>\n                            </PROVIDED-COM-SPECS>\n                            <PROVIDED-INTERFACE-TREF DEST=\"SERVICE-INTERFACE\">/Interfaces/ProvidedInterface</PROVIDED-INTERFACE-TREF>\n                        </P-PORT-PROTOTYPE>\n                    </PORTS>\n                </ADAPTIVE-APPLICATION-SW-COMPONENT-TYPE>\n            </ELEMENTS>\n            <AR-PACKAGES/>\n        </AR-PACKAGE>\n    </AR-PACKAGES>\n</AUTOSAR>\n"},{"name":"LaneGuidance_datatype.arxml","type":"other","group":"interface","path":"/home/dahyun/Documents/MATLAB/Examples/R2023b/autosarblockset/CreateAndConfigureAUTOSARAdaptiveSoftwareComponentExample/LaneGuidance_autosar_adaptive","tag":"arxml","groupDisplay":"Interface files","code":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!--\nAuto generated XML Component Description for model LaneGuidance\nModel version                : 9.0\nSimulink Coder version       : Simulink Coder 23.2 (R2023b) 01-Aug-2023\nXML source code generated on : Wed Jan 24 16:42:07 2024\nModel Checksum               : 3558035547 2812919 2844783055 1948640339\n-->\n<AUTOSAR xmlns=\"http://autosar.org/schema/r4.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://autosar.org/schema/r4.0 AUTOSAR_00050.xsd\">\n    <AR-PACKAGES>\n        <AR-PACKAGE>\n            <SHORT-NAME>AUTOSAR</SHORT-NAME>\n            <AR-PACKAGES>\n                <AR-PACKAGE>\n                    <SHORT-NAME>StdTypes</SHORT-NAME>\n                    <ELEMENTS>\n                        <STD-CPP-IMPLEMENTATION-DATA-TYPE UUID=\"05010b3e-61d4-53f1-3046-68c3156648f9\">\n                            <SHORT-NAME>double</SHORT-NAME>\n                            <CATEGORY>VALUE</CATEGORY>\n                        </STD-CPP-IMPLEMENTATION-DATA-TYPE>\n                    </ELEMENTS>\n                </AR-PACKAGE>\n            </AR-PACKAGES>\n        </AR-PACKAGE>\n    </AR-PACKAGES>\n</AUTOSAR>\n"},{"name":"LaneGuidance_interface.arxml","type":"other","group":"interface","path":"/home/dahyun/Documents/MATLAB/Examples/R2023b/autosarblockset/CreateAndConfigureAUTOSARAdaptiveSoftwareComponentExample/LaneGuidance_autosar_adaptive","tag":"arxml","groupDisplay":"Interface files","code":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!--\nAuto generated XML Component Description for model LaneGuidance\nModel version                : 9.0\nSimulink Coder version       : Simulink Coder 23.2 (R2023b) 01-Aug-2023\nXML source code generated on : Wed Jan 24 16:42:07 2024\nModel Checksum               : 3558035547 2812919 2844783055 1948640339\n-->\n<AUTOSAR xmlns=\"http://autosar.org/schema/r4.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://autosar.org/schema/r4.0 AUTOSAR_00050.xsd\">\n    <AR-PACKAGES>\n        <AR-PACKAGE>\n            <SHORT-NAME>Interfaces</SHORT-NAME>\n            <ELEMENTS>\n                <SERVICE-INTERFACE UUID=\"2b78f723-a8e6-535c-55d0-36719b316e29\">\n                    <SHORT-NAME>ProvidedInterface</SHORT-NAME>\n                    <EVENTS>\n                        <VARIABLE-DATA-PROTOTYPE UUID=\"c9fe09bf-34e6-53a0-5f86-e79856b33a3e\">\n                            <SHORT-NAME>LeftHazardIndicator</SHORT-NAME>\n                            <CATEGORY>VALUE</CATEGORY>\n                            <SW-DATA-DEF-PROPS>\n                                <SW-DATA-DEF-PROPS-VARIANTS>\n                                    <SW-DATA-DEF-PROPS-CONDITIONAL>\n                                        <SW-CALIBRATION-ACCESS>READ-ONLY</SW-CALIBRATION-ACCESS>\n                                        <SW-IMPL-POLICY>QUEUED</SW-IMPL-POLICY>\n                                    </SW-DATA-DEF-PROPS-CONDITIONAL>\n                                </SW-DATA-DEF-PROPS-VARIANTS>\n                            </SW-DATA-DEF-PROPS>\n                            <TYPE-TREF DEST=\"STD-CPP-IMPLEMENTATION-DATA-TYPE\">/AUTOSAR/StdTypes/double</TYPE-TREF>\n                        </VARIABLE-DATA-PROTOTYPE>\n                        <VARIABLE-DATA-PROTOTYPE UUID=\"b2c7f253-c153-53ce-b5dc-8a91f3bba07e\">\n                            <SHORT-NAME>RightHazardIndicator</SHORT-NAME>\n                            <CATEGORY>VALUE</CATEGORY>\n                            <SW-DATA-DEF-PROPS>\n                                <SW-DATA-DEF-PROPS-VARIANTS>\n                                    <SW-DATA-DEF-PROPS-CONDITIONAL>\n                                        <SW-CALIBRATION-ACCESS>READ-ONLY</SW-CALIBRATION-ACCESS>\n                                        <SW-IMPL-POLICY>QUEUED</SW-IMPL-POLICY>\n                                    </SW-DATA-DEF-PROPS-CONDITIONAL>\n                                </SW-DATA-DEF-PROPS-VARIANTS>\n                            </SW-DATA-DEF-PROPS>\n                            <TYPE-TREF DEST=\"STD-CPP-IMPLEMENTATION-DATA-TYPE\">/AUTOSAR/StdTypes/double</TYPE-TREF>\n                        </VARIABLE-DATA-PROTOTYPE>\n                    </EVENTS>\n                </SERVICE-INTERFACE>\n                <SERVICE-INTERFACE UUID=\"ab09c158-5c69-5a99-f904-31cbb0a2fce2\">\n                    <SHORT-NAME>RequiredInterface</SHORT-NAME>\n                    <EVENTS>\n                        <VARIABLE-DATA-PROTOTYPE UUID=\"a09c57e8-0d1f-5764-b87e-4d656a9a63a6\">\n                            <SHORT-NAME>LeftLaneDistance</SHORT-NAME>\n                            <CATEGORY>VALUE</CATEGORY>\n                            <SW-DATA-DEF-PROPS>\n                                <SW-DATA-DEF-PROPS-VARIANTS>\n                                    <SW-DATA-DEF-PROPS-CONDITIONAL>\n                                        <SW-CALIBRATION-ACCESS>READ-ONLY</SW-CALIBRATION-ACCESS>\n                                        <SW-IMPL-POLICY>QUEUED</SW-IMPL-POLICY>\n                                    </SW-DATA-DEF-PROPS-CONDITIONAL>\n                                </SW-DATA-DEF-PROPS-VARIANTS>\n                            </SW-DATA-DEF-PROPS>\n                            <TYPE-TREF DEST=\"STD-CPP-IMPLEMENTATION-DATA-TYPE\">/AUTOSAR/StdTypes/double</TYPE-TREF>\n                        </VARIABLE-DATA-PROTOTYPE>\n                        <VARIABLE-DATA-PROTOTYPE UUID=\"1c0448ce-c0db-53ab-92b0-0c508cdebd01\">\n                            <SHORT-NAME>LeftTurnIndicator</SHORT-NAME>\n                            <CATEGORY>VALUE</CATEGORY>\n                            <SW-DATA-DEF-PROPS>\n                                <SW-DATA-DEF-PROPS-VARIANTS>\n                                    <SW-DATA-DEF-PROPS-CONDITIONAL>\n                                        <SW-CALIBRATION-ACCESS>READ-ONLY</SW-CALIBRATION-ACCESS>\n                                        <SW-IMPL-POLICY>QUEUED</SW-IMPL-POLICY>\n                                    </SW-DATA-DEF-PROPS-CONDITIONAL>\n                                </SW-DATA-DEF-PROPS-VARIANTS>\n                            </SW-DATA-DEF-PROPS>\n                            <TYPE-TREF DEST=\"STD-CPP-IMPLEMENTATION-DATA-TYPE\">/AUTOSAR/StdTypes/double</TYPE-TREF>\n                        </VARIABLE-DATA-PROTOTYPE>\n                        <VARIABLE-DATA-PROTOTYPE UUID=\"124c37ca-e909-53cf-2981-0bacbc8598d8\">\n                            <SHORT-NAME>RightLaneDistance</SHORT-NAME>\n                            <CATEGORY>VALUE</CATEGORY>\n                            <SW-DATA-DEF-PROPS>\n                                <SW-DATA-DEF-PROPS-VARIANTS>\n                                    <SW-DATA-DEF-PROPS-CONDITIONAL>\n                                        <SW-CALIBRATION-ACCESS>READ-ONLY</SW-CALIBRATION-ACCESS>\n                                        <SW-IMPL-POLICY>QUEUED</SW-IMPL-POLICY>\n                                    </SW-DATA-DEF-PROPS-CONDITIONAL>\n                                </SW-DATA-DEF-PROPS-VARIANTS>\n                            </SW-DATA-DEF-PROPS>\n                            <TYPE-TREF DEST=\"STD-CPP-IMPLEMENTATION-DATA-TYPE\">/AUTOSAR/StdTypes/double</TYPE-TREF>\n                        </VARIABLE-DATA-PROTOTYPE>\n                        <VARIABLE-DATA-PROTOTYPE UUID=\"e5cd6529-670c-5af9-57d6-82ddfe7c109c\">\n                            <SHORT-NAME>RightTurnIndicator</SHORT-NAME>\n                            <CATEGORY>VALUE</CATEGORY>\n                            <SW-DATA-DEF-PROPS>\n                                <SW-DATA-DEF-PROPS-VARIANTS>\n                                    <SW-DATA-DEF-PROPS-CONDITIONAL>\n                                        <SW-CALIBRATION-ACCESS>READ-ONLY</SW-CALIBRATION-ACCESS>\n                                        <SW-IMPL-POLICY>QUEUED</SW-IMPL-POLICY>\n                                    </SW-DATA-DEF-PROPS-CONDITIONAL>\n                                </SW-DATA-DEF-PROPS-VARIANTS>\n                            </SW-DATA-DEF-PROPS>\n                            <TYPE-TREF DEST=\"STD-CPP-IMPLEMENTATION-DATA-TYPE\">/AUTOSAR/StdTypes/double</TYPE-TREF>\n                        </VARIABLE-DATA-PROTOTYPE>\n                        <VARIABLE-DATA-PROTOTYPE UUID=\"2c7d585f-e8cf-592e-a6d9-72fa1835bdd7\">\n                            <SHORT-NAME>LeftCarInBlindSpot</SHORT-NAME>\n                            <CATEGORY>VALUE</CATEGORY>\n                            <SW-DATA-DEF-PROPS>\n                                <SW-DATA-DEF-PROPS-VARIANTS>\n                                    <SW-DATA-DEF-PROPS-CONDITIONAL>\n                                        <SW-CALIBRATION-ACCESS>READ-ONLY</SW-CALIBRATION-ACCESS>\n                                        <SW-IMPL-POLICY>QUEUED</SW-IMPL-POLICY>\n                                    </SW-DATA-DEF-PROPS-CONDITIONAL>\n                                </SW-DATA-DEF-PROPS-VARIANTS>\n                            </SW-DATA-DEF-PROPS>\n                            <TYPE-TREF DEST=\"STD-CPP-IMPLEMENTATION-DATA-TYPE\">/AUTOSAR/StdTypes/double</TYPE-TREF>\n                        </VARIABLE-DATA-PROTOTYPE>\n                        <VARIABLE-DATA-PROTOTYPE UUID=\"26eefc42-16fd-50f2-aa3b-9eabe5c7474f\">\n                            <SHORT-NAME>RightCarInBlindSpot</SHORT-NAME>\n                            <CATEGORY>VALUE</CATEGORY>\n                            <SW-DATA-DEF-PROPS>\n                                <SW-DATA-DEF-PROPS-VARIANTS>\n                                    <SW-DATA-DEF-PROPS-CONDITIONAL>\n                                        <SW-CALIBRATION-ACCESS>READ-ONLY</SW-CALIBRATION-ACCESS>\n                                        <SW-IMPL-POLICY>QUEUED</SW-IMPL-POLICY>\n                                    </SW-DATA-DEF-PROPS-CONDITIONAL>\n                                </SW-DATA-DEF-PROPS-VARIANTS>\n                            </SW-DATA-DEF-PROPS>\n                            <TYPE-TREF DEST=\"STD-CPP-IMPLEMENTATION-DATA-TYPE\">/AUTOSAR/StdTypes/double</TYPE-TREF>\n                        </VARIABLE-DATA-PROTOTYPE>\n                    </EVENTS>\n                </SERVICE-INTERFACE>\n            </ELEMENTS>\n        </AR-PACKAGE>\n    </AR-PACKAGES>\n</AUTOSAR>\n"},{"name":"PosixExecutor.hpp","type":"header","group":"Other","path":"/usr/local/MATLAB/R2023b/toolbox/coder/simulinkcoder/src/executor","tag":"","groupDisplay":"Other files","code":"#pragma once\n\n#include <iostream>\n#include <vector>\n#include <csignal>\n#include <atomic>\n#include <algorithm>\n#include <exception>\n#include <cmath>\n#include <numeric>\n#include <memory>\n#include <ctime>\n\n#include <semaphore.h>\n#include <signal.h>\n#include <cstring>\n\n\n\n#include \"WorkerPool.hpp\"\n#include \"Timer.hpp\"\n\nnamespace platform {\nnamespace runtime {\n\n/** @brief A global flag to control the termination of executor\n */\nvolatile std::sig_atomic_t haltExecutor = false;\nsem_t haltSemaphore;\n\n\n/** @brief The signal handler which is invoked to terminate the executor when\n *        a SIGINT or SIGTERM signal occurs\n *\n *  @param The signal number\n*/\nvoid ctrlCHandler(int signalNum) {\n    if((signalNum == SIGINT) || (signalNum == SIGTERM)) {\n        // Consider aborting the program directly to avoid the synchronization problem\n        haltExecutor = true;\n        sem_post(&haltSemaphore);\n    }\n}\n\n\n/** @brief An executor monitors events given by users and dispatches the handlers of triggered events\n *          to threads for execution. Currently the supported types of events are periodic and aperiodic.\n *\n *  Usage:\n *     platform::runtime::Executor executor;\n *\n *     executor.addEvent([](){ std::this_thread::sleep_for(std::chrono::seconds(5)); },\n *                        [](){ std::cout << \"Event B is triggered\" << std::endl; });\n *\n *     executor.addPeriodicEvent([](){ std::cout << \"Event A (period=2 ticks) is triggered\\n\" << std::endl; }, 2);\n *\n *     executor.run();\n*/\nclass Executor {\n\n    private:\n\n        /** @brief A logger using standard output streams\n         *\n         *  Default logger type which is used as the logger template parameter in the `run()` methods\n         *  when users do not provide a logger. For example, when logging is not needed.\n         */\n        struct DefaultLogger {\n            std::ostream& LogVerbose() { return std::cout; }\n            std::ostream& LogError()   { return std::cerr; }\n        };\n\n    public:\n\n        Executor(size_t numWorkers=0) : workerPool(numWorkers) { }\n\n        ~Executor() {\n            stop();\n        }\n\n        Executor(const Executor& other) = delete;\n        Executor(Executor&& other) = delete;\n\n        Executor& operator = (const Executor& other) = delete;\n        Executor& operator = (Executor&& other) = delete;\n\n        /** @brief Function for adding a periodic event.\n         *\n         *  @param handler The event handler which gets called when the event is triggered\n         *  @param tick The period of the event\n         *  @param offset A time shift relative to the period\n        */\n        void addPeriodicEvent(std::function<void()>&& handler, const size_t tick, const size_t offset=0) {\n            periodicEvents.push_back(std::unique_ptr<PeriodicEvent>(\n                        new PeriodicEvent(tick, std::move(handler), offset)));\n        }\n\n        /** @brief Function for adding an aperiodic event.\n         *\n         *  @param waitFun The event to be monitored\n         *  @param handler The event handler which gets called when the event is triggered\n         *  @param haltFun The function to enable the waiting thread to return early from the waitFun\n        */\n        void addEvent(std::function<bool()>&& waitFun, std::function<void()> &&handler,\n                std::function<void()> &&haltFun) {\n            aperiodicEvents.push_back(std::unique_ptr<AperiodicEvent>(\n                        new AperiodicEvent(std::move(waitFun), std::move(handler), std::move(haltFun))));\n        }\n\n        /** @brief Set up the base rate of timer. This is only used for periodic events.\n         *\n         *  A base rate is the time unit (in seconds) of a tick, e.g. if baseRate = 2 seconds,\n         *  then one tick is 2 seconds. A periodic event uses ticks to represent the length\n         *  of its period,\n         *\n         *  Example:\n         *    Assume baseRate = 2 seconds, then a periodic event with 3 ticks means this\n         *    event will repeatedly trigger every 6 seconds (3 ticks * baseRate)\n         *\n         *  @param rate The base rate in seconds\n        */\n        void setBaseRateInSeconds(const std::chrono::duration<double> rate) {\n            assert(rate.count() > 0.0);\n            baseRate = rate;\n        }\n\n        /** @brief Run with a stop condition.\n         *\n         *  @param condition A callable to decide if the execution should stop\n        */\n        void run(std::function<bool()>&& condition) {\n            run<std::function<bool()>, DefaultLogger>(condition, nullptr, -1);\n        }\n\n        /** @brief Run with a stop condition passed in the current tick.\n         *\n         *  @param condition A callable passed in the current tick to decide if the execution should stop\n        */\n        void run(std::function<bool(size_t)>&& condition) {\n            run<std::function<bool(size_t)>, DefaultLogger>(condition, nullptr, -1);\n        }\n\n        /** @brief Run with a stop condition and a logger.\n         *\n         *  Example:\n         *     CustomLogger logger;\n         *     int counter = 0;\n         *\n         *     // Users provide a stop condition and a logger.\n         *     executor.run([&counter](){ return counter ++ > 10; }, logger);\n         *\n         *  @param condition A callable that checks if the execution should stop (return true)\n         *  @param logger A user-provided logger\n        */\n        // A logger and a stop condition\n        template <typename LoggerT>\n        void run(std::function<bool()>&& condition, LoggerT& logger) {\n            run(condition, &logger, -1);\n        }\n\n        /** @brief Run with a stop condition passed in the current tick and a logger.\n         *\n         *  Example:\n         *     CustomLogger logger;\n         *     int counter = 0;\n         *\n         *     // Run with a stop condition checking current tick, and a logger\n         *     executor.run([&counter](size_t currentTick){\n         *         return (counter ++ > 10) || currentTick > 10;\n         *      }, logger);\n         *\n         *  @param condition A callable passed in the current tick (size_t) to decide if the execution should stop\n         *  @param logger A user-provided logger\n        */\n        template <typename LoggerT>\n        void run(std::function<bool(size_t)>&& condition, LoggerT& logger) {\n            run(condition, &logger, -1);\n        }\n\n        /** @brief Run with a logger and an optional time limit (default is -1 which means infinite)\n         *\n         *  @param logger A user-provided logger\n         *  @param tickLimit Total number of ticks allowed for the execution\n        */\n        template <typename LoggerT>\n        void run(LoggerT& logger, int tickLimit=-1) {\n            auto fcn = []() -> bool { return false; };\n            run(fcn, &logger, tickLimit);\n        }\n\n        /** @brief Run without an optional time limit (default is -1 which means infinite)\n         *\n         *  Example:\n         *      executor.run();\n         *\n         *  @param tickLimit Total number of ticks allowed for the execution\n         */\n        void run(int tickLimit=-1) {\n            auto fcn = []() -> bool { return false; };\n            run<decltype(fcn), DefaultLogger>(fcn, nullptr, tickLimit);\n        }\n\n    private:\n\n        /** @brief The event base class - each event (regardless of the type) must have a handler\n         *\n         *  The executor guarantees:\n         *    1. The handler will be invoked as many times as the event gets triggered.\n         *    2. The handler will be invoked sequentially even the event gets triggered multiple \n         *    times in a short period.\n         *\n         *  Users need to guarantee:\n         *     There is no data race between concurrent events and handlers.\n         */\n        struct Event {\n            Event(std::function<void()> &&aHandler): handler(std::move(aHandler)) {}\n\n            std::function<void()> handler;\n\n            /** @brief remainRuns records the number of times the handler needs to be executed\n             *\n             *  Whenever the event gets triggered, remainRuns is incremented by 1\n             *  and the remainRuns is decremented by 1 everytime after the handler is executed.\n             *  This can be used for overrun detection.\n             */\n            std::atomic<int> remainRuns {0};\n\n            void operator()() {\n               auto numRuns = remainRuns.load();\n               while(numRuns > 0) {\n                   for(int i=0; i<numRuns; i++) {\n                       handler();\n                   }\n                   const int numFinishedRuns {numRuns};\n                   numRuns = remainRuns.fetch_sub(numFinishedRuns) - numFinishedRuns;\n               }\n            }\n        };\n\n        struct PeriodicEvent final: public Event {\n            PeriodicEvent(size_t aTick, std::function<void()> &&aHandler, size_t aOffset):\n                Event(std::move(aHandler)), tick(aTick), offset(aOffset) {}\n            size_t tick {1};\n            size_t offset {0};\n        };\n\n        /** @brief Aperiodic events are triggered irregularly\n         *\n         *  An aperiodic event might never be triggered or triggered after a long time, and thus\n         *  a haltFun is required to allow the thread waiting for the aperiodic event to return\n         *  early when the executor terminates.\n         */\n        struct AperiodicEvent final: public Event {\n            AperiodicEvent(std::function<bool()> &&event, std::function<void()> &&handler, std::function<void()> &&haltFun):\n                Event(std::move(handler)), waitFun(std::move(event)), haltFun(std::move(haltFun)) {}\n            std::function<bool()> waitFun;\n            std::function<void()> haltFun;\n        };\n\n        std::vector<std::unique_ptr<PeriodicEvent>> periodicEvents;\n        std::vector<std::unique_ptr<AperiodicEvent>> aperiodicEvents;\n\n        std::vector<std::thread> waiters;\n        utility::WorkerPool workerPool;\n\n        bool start {false};\n        std::chrono::duration<double> baseRate {0.0};\n\n        std::condition_variable cv;\n        std::mutex mtx;\n\n        /** @brief The function to be called by the threads monitoring aperiodic events\n         *\n         *  The function executed by the threads which wait for aperiodic events.\n         *  Executor creates a thread (called waiter) to wait for each aperiodic event. The waiter\n         *  will call the `waitFun` which returns when the aperiodic event is triggered.\n         *  The `index` is the index of the aperiodic event in the vector.\n         *\n         *  @param index The index of the aperiodic event monitored by the thread\n        */\n        void waiterLoop(const int index);\n\n\n        /** @brief Schedule periodic events if any\n         *\n         *  Create a timer armed with the base rate to schedule the periodic events and dispatch\n         *  the handlers of triggered events to execution. This function is called by the main\n         *  thread only when periodic events exist.\n         *\n         *  @param logger An optional logger which will be called to emit information\n         *  @param tickLimit An optional time limit\n        */\n        template <typename LoggerT, typename CallableT>\n        void schedulePeriodicEvents(LoggerT* logger, int tickLimit=-1, CallableT& condition = nullptr);\n\n\n        /** @brief Register the SIGINT & SIGTERM signal handler which will terminate the executor when signaled\n         */\n        bool registerCtrlC() {\n            if(std::signal(SIGINT, ctrlCHandler) == SIG_ERR ||\n               std::signal(SIGTERM, ctrlCHandler) == SIG_ERR) {\n                return false;\n            }\n            return true;\n        }\n\n        /** @brief Invoke the halt function to enable early return from aperiodic events\n         *\n         *  Notify waiters to return from waitFun. Without this, waiters might get stuck indefinitely\n         */\n        void unblockWaiters() {\n            std::for_each(aperiodicEvents.begin(), aperiodicEvents.end(),\n                    [](std::unique_ptr<AperiodicEvent>& e){ e->haltFun(); });\n        }\n\n        /**  @brief Terminate the executor and join all threads (workers & waiters)\n         */\n        void stop();\n\n        /**  @brief Check the given condition to see the executor should stop or not\n         */\n        template<typename CallableT>\n        bool shouldStop(CallableT& condition, size_t currentTick, std::false_type) {\n            return condition(currentTick);\n        }\n        template<typename CallableT>\n        bool shouldStop(CallableT& condition, size_t, std::true_type) {\n            return condition();\n        }\n\n        /** @brief This function implements the logic to schedule all events\n         *\n         *  All other run() methods will call this function to start the event execution\n         *\n         *  @param logger An optional logger which will be called to emit information\n         *  @param tickLimit An optional time limit\n         */\n        template <typename CallableT, typename LoggerT>\n        void run(CallableT& condition, LoggerT *logger=nullptr, int tickLimit=-1);\n\n\n        /** @brief An utility function to calculate the greatest common divisor of two numbers\n         */\n        size_t gcd(size_t a, size_t b) const { return (b == 0) ? a : gcd(b, a%b); }\n\n        /** @brief An utility function to disable handler of SIGINT and SIGTERM\n         */\n        template<typename LoggerT>\n        void blockSignals(LoggerT* logger=nullptr);\n\n        /** @brief An utility function to enable handler of SIGINT and SIGTERM\n         */\n        template<typename LoggerT>\n        void unblockSignals(LoggerT* logger=nullptr);\n};\n\n\nvoid Executor::stop() {\n    {\n        std::lock_guard<std::mutex> lock {mtx};\n        start = false;\n        haltExecutor = true;\n    }\n    cv.notify_all();\n\n    const auto joinThread = [](std::thread& thd){\n      if(thd.joinable()) {\n          thd.join();\n      }\n    };\n\n    std::for_each(waiters.begin(), waiters.end(), joinThread);\n}\n\nvoid Executor::waiterLoop(const int index) {\n    std::unique_lock<std::mutex> lock {mtx};\n    cv.wait(lock, [this]() -> bool { return haltExecutor || this->start; });\n\n    while(start && !haltExecutor) {\n        lock.unlock();\n        const bool isTriggered = aperiodicEvents[index]->waitFun();\n        if(!isTriggered) {\n            break;\n        }\n\n        const bool isDispatched = (aperiodicEvents[index]->remainRuns.fetch_add(1) != 0);\n        if(!isDispatched) {\n            workerPool.post([this, index](){ (*this->aperiodicEvents[index])(); });\n        }\n        lock.lock();\n    }\n}\n\ntemplate <typename LoggerT, typename CallableT>\nvoid Executor::schedulePeriodicEvents(LoggerT *logger, int tickLimit, CallableT& condition) {\n\n    // Sort periodic events in decreasing order based on the ticks. This is for ERT's\n    // rate-monotonic scheduling (short cycle events get triggered first.).\n    std::sort(periodicEvents.begin(), periodicEvents.end(),\n        [](const std::unique_ptr<PeriodicEvent>& e1, const std::unique_ptr<PeriodicEvent>& e2) -> bool {\n            return e1->tick < e2->tick;\n        }\n    );\n\n    const auto lcm = std::accumulate(periodicEvents.begin(), periodicEvents.end(), 1U,\n        [this](size_t lcm, const std::unique_ptr<PeriodicEvent>& event) -> size_t {\n            return (lcm * event->tick) / gcd(lcm, event->tick);\n        }\n    );\n\n    utility::Timer timer {baseRate};\n\n    // Notify waiters to start monitoring aperiodic events if any\n    if(!aperiodicEvents.empty()) {\n        std::lock_guard<std::mutex> lock {mtx};\n        start = true;\n        cv.notify_all();\n    }\n\n    blockSignals<LoggerT>(logger);\n    timer.start();\n    unblockSignals<LoggerT>(logger);\n\n    size_t tickCounter {0};\n    size_t currentTick {0};\n\n    while(tickLimit != 0) {\n        // Wait for timer pass one tick (period)\n        try {\n            timer.wait();\n        }\n        catch (const std::exception&) {\n            if(logger != nullptr) {\n                logger->LogError() << \"Error: an error occurs in timer wait function\\n\";\n            }\n            break;\n        }\n\n        // The haltExecutor might be set (signaled) when waiting for the timer to expire. \n        // So, we have to check haltExecutor after a tick passed and before dispatching \n        // the event handlers.\n        if(haltExecutor) {\n            break;\n        }\n\n        for(size_t i=0; i<periodicEvents.size(); i++) {\n            if((tickCounter+1) % periodicEvents[i]->tick == periodicEvents[i]->offset) {\n                if(periodicEvents[i]->remainRuns.fetch_add(1) == 0) {\n                    workerPool.post([this, i](){ (*this->periodicEvents[i])(); });\n                }\n                else {\n                    // Prior executions are not finished yet while the event gets triggered again\n                    if(logger != nullptr) {\n                        logger->LogVerbose() << \"INFO: Overrun detected: Periodic event \" << i << \" triggers too fast\\n\";\n                    }\n                }\n            }\n        }\n\n        tickCounter = (tickCounter+1)%lcm;\n        currentTick ++;\n\n        const bool isLastTick {(tickLimit > 0) && (--tickLimit == 0)};\n        using isVoidInputType = std::is_constructible<std::function<bool(void)>,\n                                                  typename std::remove_reference<CallableT>::type>;\n        if(isLastTick || shouldStop(condition, currentTick, isVoidInputType())) {\n            workerPool.wait();\n            break;\n        }\n\n    } // End of periodic event schedule loop\n\n}\n\ntemplate <typename CallableT, typename LoggerT>\nvoid Executor::run(CallableT& condition, LoggerT* logger, int tickLimit) {\n\n    // tickLimit should be either a positive number if a runtime limit is given\n    // OR -1 if there is no limit imposed (terminated by signal only)\n    assert(tickLimit != 0);\n\n    if(!registerCtrlC()) {\n        if(logger != nullptr) {\n            logger->LogError() << \"Signal Registration fails!\\n\";\n        }\n        return;\n    }\n    sem_init(&haltSemaphore, 0, 0U);\n\n    if(periodicEvents.empty() && aperiodicEvents.empty()) {\n        // Currently aperiodic step functions (adaptive AUTOSAR model) are\n        // called directly inside main.cpp. If there is no periodic step\n        // functions, the executor should still wait until signaled termination.\n        sem_wait(&haltSemaphore);\n        sem_destroy(&haltSemaphore);\n        return;\n    }\n\n    workerPool.start();\n    for(size_t i {0}; i<aperiodicEvents.size(); i++) {\n        waiters.emplace_back([this, i] () { this->waiterLoop(i); });\n    }\n\n    if(!periodicEvents.empty()) {\n        schedulePeriodicEvents<LoggerT, CallableT>(logger, tickLimit, condition);\n    }\n    else {\n        {\n            // Notify waiters to start monitoring aperiodic events\n            std::lock_guard<std::mutex> lock {mtx};\n            start = true;\n            cv.notify_all();\n        }\n\n        if(tickLimit < 0) {\n            // Wait until interrupted by signals if users do not specify a time limit \n            // Note: with semaphore, only main thread can be interrupted and there is \n            //       no need to periodically wake up to check the halt flag\n            sem_wait(&haltSemaphore);\n        }\n        else {\n            struct timespec ts;\n            ts.tv_sec = tickLimit*std::chrono::duration<double>(baseRate).count();\n            ts.tv_nsec = (tickLimit*std::chrono::duration<double>(baseRate).count() - ts.tv_sec)*1e9;\n            // Wait until either time out or interrupted by signals\n            sem_timedwait(&haltSemaphore, &ts);\n        }\n    }\n    sem_destroy(&haltSemaphore);\n    unblockWaiters();\n    stop();\n}\n\n\ntemplate <typename LoggerT>\nvoid Executor::blockSignals(LoggerT *logger)\n{\n    constexpr int32_t FAIL_SIGN{-1};\n\n    sigset_t sigset;\n    sigemptyset(&sigset);\n    sigaddset(&sigset, SIGRTMIN);\n    sigaddset(&sigset, SIGTERM);\n    if (pthread_sigmask(SIG_SETMASK, &sigset, NULL) == FAIL_SIGN && logger != nullptr) {\n        logger->LogError() << \"Blocking signals failed: \" << std::strerror(errno);\n    }\n}\n\ntemplate <typename LoggerT>\nvoid Executor::unblockSignals(LoggerT *logger)\n{\n    constexpr int32_t FAIL_SIGN{-1};\n\n    sigset_t sigset;\n    sigemptyset(&sigset);\n    sigaddset(&sigset, SIGRTMIN);\n    sigaddset(&sigset, SIGTERM);\n    if (pthread_sigmask(SIG_UNBLOCK, &sigset, NULL) == FAIL_SIGN && logger != nullptr) {\n        logger->LogError() << \"Unblocking signals failed: \" << std::strerror(errno);\n    }\n}\n\n\n\n} // End of runtime namespace\n} // End of platform namespace\n\n\n"},{"name":"main.cpp","type":"source","group":"legacy","path":"/home/dahyun/Documents/MATLAB/Examples/R2023b/autosarblockset/CreateAndConfigureAUTOSARAdaptiveSoftwareComponentExample/LaneGuidance_autosar_adaptive","tag":"","groupDisplay":"Other files","code":"/* Code generated for Simulink model LaneGuidance */\n/* Generated on 24-Jan-2024 */\n\n#include <cstdint>\n#include <exception>\n#include <chrono>\n#include <functional>\n#include \"PosixExecutor.hpp\"\n#include <ara/core/initialization.h>\n#include <ara/core/result.h>\n#include <ara/core/string_view.h>\n#include <ara/exec/execution_client.h>\n#include <ara/log/common.h>\n#include <ara/log/logger.h>\n#include <ara/log/log_stream.h>\n#include \"LaneGuidance.h\"\n\n/* main() handles the following: */\n/*  - Instantiates the model object and owns its memory. */\n/*  - Reports the Execution state to ARA */\n/*  - Calls the model's initialize and terminate functions. */\n/*  - Creates an executor instance to schedule the periodic step functions */\n/*       - A timer that is set to the base rate is created in the executor */\n/*       - The step functions are added to the executor and run */\n/*         based on their sample periods */\nint32_t main() {\n  /* Used to control the flow in case of error in any api's used. */\n  bool bProceed{true};\n  /* Used to decide whether ara function clusters has been initialized. */\n  bool bAraInitialized{true};\n  /* ara function cluster init. */\n  const ara::core::Result<void> initStatus{ara::core::Initialize()};\n\n  if (!initStatus.HasValue()) {\n    bProceed = false;\n    bAraInitialized = false;\n  } /* if */\n\n  if (bAraInitialized) {\n    ara::log::Logger &araLog{ara::log::CreateLogger(\n        ara::core::StringView{\"Lane\"},\n        ara::core::StringView{\"Logger for LaneGuidance's main function.\"},\n        ara::log::LogLevel::kWarn)};\n\n    /* Report Execution state */\n    ara::exec::ExecutionClient exec_client;\n    try {\n      if (!exec_client.ReportExecutionState(\n              ara::exec::ExecutionState::kRunning)) {\n        araLog.LogError() << \"Unable to report running state: \"\n                             \"ara::exec::ExecutionReturnType::kGeneralError.\\n\";\n        bProceed = false;\n      } else {\n        araLog.LogVerbose() << \"Adaptive application entering running state.\";\n      } /* if */\n    } catch (std::exception const &e) {\n      araLog.LogError() << \"Unable to report running state due to exception: \"\n                        << e.what() << \".\\n\";\n      bProceed = false;\n    }\n\n    LaneGuidance LaneGuidance_Obj;\n    if (bProceed) {\n      /* Initialize Functions */\n      try {\n        LaneGuidance_Obj.initialize();\n      } catch (std::exception const &e) {\n        araLog.LogError() << \"Unable to initialize: \" << e.what() << \".\\n\";\n        bProceed = false;\n      }\n    } /* if */\n\n    if (bProceed) {\n      /* Create an executor instance to schedule the periodic step functions */\n      /* Whenever the period of a step function passes, the executor */\n      /* schedules that step function to be executed on a thread. */\n      platform::runtime::Executor fcnExecutor;\n\n      /* Base rate is the time unit of a tick */\n      const double baseRate{0.100000};\n      fcnExecutor.setBaseRateInSeconds(std::chrono::duration<double>(baseRate));\n\n      /* Register periodic step functions in the executor. */\n      fcnExecutor.addPeriodicEvent(\n          [&LaneGuidance_Obj, &araLog]() {\n            try {\n              LaneGuidance_Obj.step();\n            } catch (std::exception const &e) {\n              araLog.LogError() << \"Error executing step: \" << e.what();\n            }\n          },\n          1);\n\n      araLog.LogVerbose() << \"Starting Step function.\";\n#if defined(rtmSetStopRequested) && defined(rtmGetStopRequested)\n      fcnExecutor.run(\n          [&LaneGuidance_Obj]() {\n            return rtmGetStopRequested(LaneGuidance_Obj.getRTM());\n          },\n          araLog);\n#else\n      fcnExecutor.run(araLog);\n#endif\n    } /* if */\n\n    if (bProceed) {\n      try {\n        /* Terminate Functions */\n        LaneGuidance_Obj.terminate();\n      } catch (std::exception const &e) {\n        araLog.LogError() << \"Unable to terminate: \" << e.what() << \".\\n\";\n        bProceed = false;\n      }\n    } /* if */\n\n    araLog.LogVerbose() << \"Exiting adaptive application.\\n\";\n    const ara::core::Result<void> deinitStatus{ara::core::Deinitialize()};\n    if (!deinitStatus.HasValue()) {\n      bAraInitialized = false;\n    } /* if */\n  }   /* if */\n\n  constexpr int32_t APP_SUCCESS{0};\n  constexpr int32_t APP_FAIL{1};\n  return ((bAraInitialized && bProceed) ? APP_SUCCESS : APP_FAIL);\n}\n"},{"name":"MachineManifest.arxml","type":"other","group":"ARA files","path":"/home/dahyun/Documents/MATLAB/Examples/R2023b/autosarblockset/CreateAndConfigureAUTOSARAdaptiveSoftwareComponentExample/LaneGuidance_autosar_adaptive/stub","tag":"arxml","groupDisplay":"ARA files","code":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!--\nAuto generated XML Component Description for model LaneGuidance\nModel version                : 9.0\nSimulink Coder version       : Simulink Coder 23.2 (R2023b) 01-Aug-2023\nXML source code generated on : Wed Jan 24 16:42:07 2024\nModel Checksum               : 3558035547 2812919 2844783055 1948640339\n-->\n<AUTOSAR xmlns=\"http://autosar.org/schema/r4.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://autosar.org/schema/r4.0 AUTOSAR_00050.xsd\">\n    <AR-PACKAGES>\n        <AR-PACKAGE>\n            <SHORT-NAME>LaneGuidance_DltApplicationToProcessMapping</SHORT-NAME>\n            <ELEMENTS>\n                <DLT-APPLICATION-TO-PROCESS-MAPPING UUID=\"6c60c0e9-c2cd-502a-d9ab-afc7140f1454\">\n                    <SHORT-NAME>DltApplicationToProcessMapping</SHORT-NAME>\n                    <DLT-APPLICATION-REF DEST=\"DLT-APPLICATION\">/LaneGuidance_DltEcu/DefaultDltEcu/DefaultDltApplication</DLT-APPLICATION-REF>\n                    <PROCESS-REF DEST=\"PROCESS\">/LaneGuidance_Processes/DefaultInstance</PROCESS-REF>\n                </DLT-APPLICATION-TO-PROCESS-MAPPING>\n            </ELEMENTS>\n        </AR-PACKAGE>\n        <AR-PACKAGE>\n            <SHORT-NAME>LaneGuidance_DltEcu</SHORT-NAME>\n            <ELEMENTS>\n                <DLT-ECU UUID=\"55501198-d0a4-5cc9-1ad5-e51c77852d30\">\n                    <SHORT-NAME>DefaultDltEcu</SHORT-NAME>\n                    <APPLICATIONS>\n                        <DLT-APPLICATION UUID=\"40798e31-f07b-5a1f-200d-db9b83aef019\">\n                            <SHORT-NAME>DefaultDltApplication</SHORT-NAME>\n                            <APPLICATION-DESCRIPTION>Log messages for adaptive application LaneGuidance</APPLICATION-DESCRIPTION>\n                            <APPLICATION-ID>3163</APPLICATION-ID>\n                        </DLT-APPLICATION>\n                    </APPLICATIONS>\n                </DLT-ECU>\n            </ELEMENTS>\n        </AR-PACKAGE>\n        <AR-PACKAGE>\n            <SHORT-NAME>LaneGuidance_DltLogSink</SHORT-NAME>\n            <ELEMENTS>\n                <DLT-LOG-SINK UUID=\"5c431160-e8e5-5a29-0479-075161e04289\">\n                    <SHORT-NAME>DefaultDltLogSink</SHORT-NAME>\n                    <CATEGORY>DLT_LOGSINK_CONSOLE</CATEGORY>\n                    <DEFAULT-LOG-THRESHOLD>WARN</DEFAULT-LOG-THRESHOLD>\n                </DLT-LOG-SINK>\n            </ELEMENTS>\n        </AR-PACKAGE>\n        <AR-PACKAGE>\n            <SHORT-NAME>MachineStates</SHORT-NAME>\n            <ELEMENTS>\n                <MODE-DECLARATION-GROUP>\n                    <SHORT-NAME>MachineFG</SHORT-NAME>\n                    <INITIAL-MODE-REF DEST=\"MODE-DECLARATION\">/MachineStates/MachineFG/Running</INITIAL-MODE-REF>\n                    <MODE-DECLARATIONS>\n                        <MODE-DECLARATION UUID=\"1cc051a9-581a-50d3-5f73-af48fdda445f\">\n                            <SHORT-NAME>Off</SHORT-NAME>\n                            <VALUE>1</VALUE>\n                        </MODE-DECLARATION>\n                        <MODE-DECLARATION UUID=\"ed652269-e5d5-5a38-62d0-5bb76ab91f26\">\n                            <SHORT-NAME>Startup</SHORT-NAME>\n                            <VALUE>2</VALUE>\n                        </MODE-DECLARATION>\n                        <MODE-DECLARATION UUID=\"fd5574ba-dcbb-515e-398f-c18ef07ad648\">\n                            <SHORT-NAME>Running</SHORT-NAME>\n                            <VALUE>3</VALUE>\n                        </MODE-DECLARATION>\n                        <MODE-DECLARATION UUID=\"432120cf-d927-558b-9bbd-c8b8e90cc115\">\n                            <SHORT-NAME>Idle</SHORT-NAME>\n                            <VALUE>4</VALUE>\n                        </MODE-DECLARATION>\n                        <MODE-DECLARATION UUID=\"e86c191c-936a-5f77-e31b-bd4331f99590\">\n                            <SHORT-NAME>Shutdown</SHORT-NAME>\n                            <VALUE>5</VALUE>\n                        </MODE-DECLARATION>\n                        <MODE-DECLARATION UUID=\"464cfb9f-babc-5d56-e595-8fa6ef30b234\">\n                            <SHORT-NAME>Restart</SHORT-NAME>\n                            <VALUE>6</VALUE>\n                        </MODE-DECLARATION>\n                        <MODE-DECLARATION UUID=\"968dbc94-1dc5-50ac-a5e1-5094fcdc49b3\">\n                            <SHORT-NAME>Verify</SHORT-NAME>\n                            <VALUE>7</VALUE>\n                        </MODE-DECLARATION>\n                    </MODE-DECLARATIONS>\n                </MODE-DECLARATION-GROUP>\n            </ELEMENTS>\n        </AR-PACKAGE>\n        <AR-PACKAGE>\n            <SHORT-NAME>Machines</SHORT-NAME>\n            <ELEMENTS>\n                <MACHINE UUID=\"718ee6a6-94c7-5cc6-f305-b921eb37c8b4\">\n                    <SHORT-NAME>Host</SHORT-NAME>\n                    <DEFAULT-APPLICATION-TIMEOUT>\n                        <ENTER-TIMEOUT-VALUE>60</ENTER-TIMEOUT-VALUE>\n                        <EXIT-TIMEOUT-VALUE>60</EXIT-TIMEOUT-VALUE>\n                    </DEFAULT-APPLICATION-TIMEOUT>\n                    <MACHINE-DESIGN-REF DEST=\"MACHINE-DESIGN\">/LaneGuidance_MachineDesign/MachineDesign</MACHINE-DESIGN-REF>\n                    <MODULE-INSTANTIATIONS>\n                        <OS-MODULE-INSTANTIATION UUID=\"99b8a3a5-d653-542f-835f-728b3d94f62c\">\n                            <SHORT-NAME>HostOsInstantiation</SHORT-NAME>\n                            <RESOURCE-GROUPS>\n                                <RESOURCE-GROUP UUID=\"156be774-5e3e-58bb-745d-6518aaed2e26\">\n                                    <SHORT-NAME>DefaultResourceGroup</SHORT-NAME>\n                                    <CPU-USAGE>100</CPU-USAGE>\n                                    <MEM-USAGE>4096000000</MEM-USAGE>\n                                </RESOURCE-GROUP>\n                            </RESOURCE-GROUPS>\n                        </OS-MODULE-INSTANTIATION>\n                        <LOG-AND-TRACE-INSTANTIATION UUID=\"5843ff12-40d4-51da-7b08-c3f11a3f27b4\">\n                            <SHORT-NAME>LaneGuidance_LogAndTraceInstantiation</SHORT-NAME>\n                            <DLT-ECU-REF DEST=\"DLT-ECU\">/LaneGuidance_DltEcu/DefaultDltEcu</DLT-ECU-REF>\n                            <LOG-SINK-REFS>\n                                <LOG-SINK-REF DEST=\"DLT-LOG-SINK\">/LaneGuidance_DltLogSink/DefaultDltLogSink</LOG-SINK-REF>\n                            </LOG-SINK-REFS>\n                        </LOG-AND-TRACE-INSTANTIATION>\n                    </MODULE-INSTANTIATIONS>\n                </MACHINE>\n            </ELEMENTS>\n        </AR-PACKAGE>\n    </AR-PACKAGES>\n</AUTOSAR>\n"},{"name":"providedinterface_common.h","type":"header","group":"ARA files","path":"/home/dahyun/Documents/MATLAB/Examples/R2023b/autosarblockset/CreateAndConfigureAUTOSARAdaptiveSoftwareComponentExample/LaneGuidance_autosar_adaptive/stub/aragen","tag":"","groupDisplay":"ARA files","code":"/* This file contains ARA Function Cluster ara::com stub implementation.\n   This implementation can be used to compile the generated code\n   in Simulink. When deploying the generated code outside of Simulink,\n   replace this file with an appropriate ARA file.\n\n   Code generated for Simulink Adaptive model: \"LaneGuidance\"\n   AUTOSAR AP Release: \"21-11\"\n   On: \"24-Jan-2024 16:40:57\"  */\n\n#ifndef PROVIDEDINTERFACE_COMMON_H_\n#define PROVIDEDINTERFACE_COMMON_H_\n#include \"ara/core/array.h\"\n#include \"ara/core/vector.h\"\n#include \"ara/core/future.h\"\n#include \"ara/core/promise.h\"\n#include \"ara/com/types.h\"\n#include \"MiddlewareFactories.h\"\n#include <fastrtps/types/DynamicData.h>\n#include <fastrtps/types/DynamicPubSubType.h>\n#include <fastrtps/types/DynamicTypeBuilderFactory.h>\n#include <fastrtps/types/DynamicDataFactory.h>\n#include <fastrtps/types/DynamicTypeBuilderPtr.h>\n#include <fastrtps/types/TypeIdentifier.h>\n#include \"DDSEndianHelper.h\"\n#include \"DDSSerializer.h\"\n#include \"AdaptiveAUTOSARDDSIdl.h\"\n#include \"AdaptiveAUTOSARDDSIdlPubSubTypes.h\"\n#include \"ProvidedInterface_araDynamicEventDDS.h\"\n#include \"ProvidedInterface_araDynamicMethodDDS.h\"\n#endif\n"},{"name":"providedinterface_skeleton.h","type":"header","group":"ARA files","path":"/home/dahyun/Documents/MATLAB/Examples/R2023b/autosarblockset/CreateAndConfigureAUTOSARAdaptiveSoftwareComponentExample/LaneGuidance_autosar_adaptive/stub/aragen","tag":"","groupDisplay":"ARA files","code":"/* This file contains ARA Function Cluster ara::com stub implementation.\n   This implementation can be used to compile the generated code\n   in Simulink. When deploying the generated code outside of Simulink,\n   replace this file with an appropriate ARA file.\n\n   Code generated for Simulink Adaptive model: \"LaneGuidance\"\n   AUTOSAR AP Release: \"21-11\"\n   On: \"24-Jan-2024 16:40:57\"  */\n\n#ifndef PROVIDEDINTERFACE_SKELETON_H_\n#define PROVIDEDINTERFACE_SKELETON_H_\n#include <memory>\n#include \"providedinterface_common.h\"\n\nnamespace skeleton\n{\n  namespace events\n  {\n    using LeftHazardIndicator = ara::com::SkeletonEvent<double>;\n    using RightHazardIndicator = ara::com::SkeletonEvent<double>;\n  }                                    /* namespace events */\n\n  namespace fields\n  {\n  }                                    /* namespace fields */\n\n  class ProvidedInterfaceSkeleton {\n   public:\n    ProvidedInterfaceSkeleton(ara::com::InstanceIdentifier instance, ara::com::\n      MethodCallProcessingMode mode = ara::com::MethodCallProcessingMode::kEvent):\n      mHndl(instance), mMethodProcMode(mode)\n    {\n    }\n\n    ProvidedInterfaceSkeleton(ara::core::InstanceSpecifier instanceSpec, ara::\n      com::MethodCallProcessingMode mode = ara::com::MethodCallProcessingMode::\n      kEvent): mMethodProcMode(mode)\n    {\n      ara::core::Result<ara::com::InstanceIdentifierContainer> vecInstance(ara::\n        com::runtime::ResolveInstanceIDs(instanceSpec));\n      if (!vecInstance->empty()) {\n        mHndl.mInstanceID = vecInstance->front();\n      }                                /* if */\n    }\n\n    virtual ~ProvidedInterfaceSkeleton()\n    {\n      StopOfferService();\n    }\n\n    ProvidedInterfaceSkeleton(const ProvidedInterfaceSkeleton&) = delete;\n    ProvidedInterfaceSkeleton& operator = (const ProvidedInterfaceSkeleton&) =\n      delete;\n    ProvidedInterfaceSkeleton(ProvidedInterfaceSkeleton&& sklObj) = default;\n    ProvidedInterfaceSkeleton& operator = (ProvidedInterfaceSkeleton&& sklObj) =\n      default;\n    inline ara::core::Result<void> OfferService()\n    {\n      ara::com::ServiceFactory::CreateService(mHndl);\n      mMethodMiddleware.reset(ara::com::MethodFactory::CreateSkeletonMethod<\n        ProvidedInterfaceSkeleton, skeleton_io::\n        ProvidedInterfaceSkeleton_mthd_dispatcher_t>(mMethodProcMode, this,\n        mHndl));\n      std::string sTopicName;\n      sTopicName = \"LeftHazardIndicator\";\n      LeftHazardIndicator.Init(ara::com::EventFactory::CreateSkeletonEvent<\n        double, skeleton_io::ProvidedInterface_LeftHazardIndicator_t>(mHndl,\n        sTopicName));\n      sTopicName = \"RightHazardIndicator\";\n      RightHazardIndicator.Init(ara::com::EventFactory::CreateSkeletonEvent<\n        double, skeleton_io::ProvidedInterface_RightHazardIndicator_t>(mHndl,\n        sTopicName));\n      return ara::core::Result<void>::FromValue();\n    }\n\n    inline void StopOfferService()\n    {\n      LeftHazardIndicator.Deinit();\n      RightHazardIndicator.Deinit();\n      ara::com::ServiceFactory::DestroyService(mHndl);\n    }\n\n    skeleton::events::LeftHazardIndicator LeftHazardIndicator;\n    skeleton::events::RightHazardIndicator RightHazardIndicator;\n   private:\n    ara::com::ServiceHandleType mHndl;\n    ara::com::MethodCallProcessingMode mMethodProcMode;\n    std::shared_ptr<ara::com::SkeletonMethodMiddlewareBase> mMethodMiddleware;\n  };\n}                                      /* namespace skeleton */\n\n#endif                                 //#ifndef PROVIDEDINTERFACE_SKELETON_H_\n"},{"name":"requiredinterface_common.h","type":"header","group":"ARA files","path":"/home/dahyun/Documents/MATLAB/Examples/R2023b/autosarblockset/CreateAndConfigureAUTOSARAdaptiveSoftwareComponentExample/LaneGuidance_autosar_adaptive/stub/aragen","tag":"","groupDisplay":"ARA files","code":"/* This file contains ARA Function Cluster ara::com stub implementation.\n   This implementation can be used to compile the generated code\n   in Simulink. When deploying the generated code outside of Simulink,\n   replace this file with an appropriate ARA file.\n\n   Code generated for Simulink Adaptive model: \"LaneGuidance\"\n   AUTOSAR AP Release: \"21-11\"\n   On: \"24-Jan-2024 16:40:57\"  */\n\n#ifndef REQUIREDINTERFACE_COMMON_H_\n#define REQUIREDINTERFACE_COMMON_H_\n#include \"ara/core/array.h\"\n#include \"ara/core/vector.h\"\n#include \"ara/core/future.h\"\n#include \"ara/core/promise.h\"\n#include \"ara/com/types.h\"\n#include \"MiddlewareFactories.h\"\n#include <fastrtps/types/DynamicData.h>\n#include <fastrtps/types/DynamicPubSubType.h>\n#include <fastrtps/types/DynamicTypeBuilderFactory.h>\n#include <fastrtps/types/DynamicDataFactory.h>\n#include <fastrtps/types/DynamicTypeBuilderPtr.h>\n#include <fastrtps/types/TypeIdentifier.h>\n#include \"DDSEndianHelper.h\"\n#include \"DDSSerializer.h\"\n#include \"AdaptiveAUTOSARDDSIdl.h\"\n#include \"AdaptiveAUTOSARDDSIdlPubSubTypes.h\"\n#include \"RequiredInterface_araDynamicEventDDS.h\"\n#include \"RequiredInterface_araDynamicMethodDDS.h\"\n#endif\n"},{"name":"requiredinterface_proxy.h","type":"header","group":"ARA files","path":"/home/dahyun/Documents/MATLAB/Examples/R2023b/autosarblockset/CreateAndConfigureAUTOSARAdaptiveSoftwareComponentExample/LaneGuidance_autosar_adaptive/stub/aragen","tag":"","groupDisplay":"ARA files","code":"/* This file contains ARA Function Cluster ara::com stub implementation.\n   This implementation can be used to compile the generated code\n   in Simulink. When deploying the generated code outside of Simulink,\n   replace this file with an appropriate ARA file.\n\n   Code generated for Simulink Adaptive model: \"LaneGuidance\"\n   AUTOSAR AP Release: \"21-11\"\n   On: \"24-Jan-2024 16:40:57\"  */\n\n#ifndef REQUIREDINTERFACE_PROXY_H_\n#define REQUIREDINTERFACE_PROXY_H_\n#include <memory>\n#include <utility>\n#include \"requiredinterface_common.h\"\n\nnamespace proxy\n{\n  namespace events\n  {\n    using LeftCarInBlindSpot = ara::com::ProxyEvent<double>;\n    using LeftLaneDistance = ara::com::ProxyEvent<double>;\n    using LeftTurnIndicator = ara::com::ProxyEvent<double>;\n    using RightCarInBlindSpot = ara::com::ProxyEvent<double>;\n    using RightLaneDistance = ara::com::ProxyEvent<double>;\n    using RightTurnIndicator = ara::com::ProxyEvent<double>;\n  }                                    /* namespace events */\n\n  namespace methods\n  {\n  }                                    /* namespace methods */\n\n  namespace fields\n  {\n  }                                    /* namespace fields */\n\n  class RequiredInterfaceProxy {\n   private:\n    ara::com::ServiceHandleType mHandle;\n   public:\n    using HandleType = ara::com::ServiceHandleType;\n    explicit RequiredInterfaceProxy(const HandleType& handle): mHandle(handle)\n    {\n      std::string sTopicName;\n      sTopicName = \"LeftCarInBlindSpot\";\n      LeftCarInBlindSpot.Init(ara::com::EventFactory::CreateProxyEvent<double,\n        proxy_io::RequiredInterface_LeftCarInBlindSpot_t>(handle, sTopicName));\n      sTopicName = \"LeftLaneDistance\";\n      LeftLaneDistance.Init(ara::com::EventFactory::CreateProxyEvent<double,\n                            proxy_io::RequiredInterface_LeftLaneDistance_t>\n                            (handle, sTopicName));\n      sTopicName = \"LeftTurnIndicator\";\n      LeftTurnIndicator.Init(ara::com::EventFactory::CreateProxyEvent<double,\n        proxy_io::RequiredInterface_LeftTurnIndicator_t>(handle, sTopicName));\n      sTopicName = \"RightCarInBlindSpot\";\n      RightCarInBlindSpot.Init(ara::com::EventFactory::CreateProxyEvent<double,\n        proxy_io::RequiredInterface_RightCarInBlindSpot_t>(handle, sTopicName));\n      sTopicName = \"RightLaneDistance\";\n      RightLaneDistance.Init(ara::com::EventFactory::CreateProxyEvent<double,\n        proxy_io::RequiredInterface_RightLaneDistance_t>(handle, sTopicName));\n      sTopicName = \"RightTurnIndicator\";\n      RightTurnIndicator.Init(ara::com::EventFactory::CreateProxyEvent<double,\n        proxy_io::RequiredInterface_RightTurnIndicator_t>(handle, sTopicName));\n    }\n\n    virtual ~RequiredInterfaceProxy()\n    {\n      LeftCarInBlindSpot.Deinit();\n      LeftLaneDistance.Deinit();\n      LeftTurnIndicator.Deinit();\n      RightCarInBlindSpot.Deinit();\n      RightLaneDistance.Deinit();\n      RightTurnIndicator.Deinit();\n    }\n\n    RequiredInterfaceProxy(const RequiredInterfaceProxy&) = delete;\n    RequiredInterfaceProxy& operator = (const RequiredInterfaceProxy&) = delete;\n    RequiredInterfaceProxy(RequiredInterfaceProxy&&) = default;\n    RequiredInterfaceProxy& operator = (RequiredInterfaceProxy&&) = default;\n    static inline ara::core::Result<ara::com::ServiceHandleContainer<\n      RequiredInterfaceProxy::HandleType>> FindService(ara::com::\n      InstanceIdentifier instance = ara::com::InstanceIdentifier::Any)\n    {\n      ara::com::ServiceHandleContainer<RequiredInterfaceProxy::HandleType>\n        retResult;\n      retResult.push_back(ara::com::ServiceFactory::FindService(instance));\n      return ara::core::Result<ara::com::ServiceHandleContainer<\n        RequiredInterfaceProxy::HandleType>>{ retResult };\n    }\n\n    static inline ara::core::Result<ara::com::ServiceHandleContainer<\n      RequiredInterfaceProxy::HandleType>> FindService(ara::core::\n      InstanceSpecifier instanceSpec)\n    {\n      ara::com::ServiceHandleContainer<RequiredInterfaceProxy::HandleType>\n        retResult;\n      ara::core::Result<ara::com::InstanceIdentifierContainer> vecInstance (ara::\n        com::runtime::ResolveInstanceIDs(instanceSpec));\n      if (!vecInstance->empty()) {\n        retResult = FindService(vecInstance->front()).Value();\n      } else {\n        retResult = FindService(ara::com::InstanceIdentifier::Any).Value();\n      }                                /* if */\n\n      return ara::core::Result<ara::com::ServiceHandleContainer<\n        RequiredInterfaceProxy::HandleType>>{ retResult };\n    }\n\n    static inline ara::core::Result<ara::com::FindServiceHandle>\n      StartFindService(ara::com::FindServiceHandler<RequiredInterfaceProxy::\n                       HandleType> handler, ara::com::InstanceIdentifier\n                       instance = ara::com::InstanceIdentifier::Any)\n    {\n      return ara::core::Result<ara::com::FindServiceHandle>{ ara::com::\n        ServiceFactory::StartFindService(handler, instance) };\n    }\n\n    static inline ara::core::Result<ara::com::FindServiceHandle>\n      StartFindService(ara::com::FindServiceHandler<RequiredInterfaceProxy::\n                       HandleType> handler, ara::core::InstanceSpecifier\n                       instanceSpec)\n    {\n      ara::com::FindServiceHandle retHandle;\n      ara::core::Result<ara::com::InstanceIdentifierContainer> vecInstance (ara::\n        com::runtime::ResolveInstanceIDs(instanceSpec));\n      if (!vecInstance->empty()) {\n        retHandle = StartFindService(handler, vecInstance->front()).Value();\n      } else {\n        retHandle = StartFindService(handler, ara::com::InstanceIdentifier::Any)\n          .Value();\n      }                                /* if */\n\n      return ara::core::Result<ara::com::FindServiceHandle>{ retHandle };\n    }\n\n    static inline void StopFindService(ara::com::FindServiceHandle handle)\n    {\n      ara::com::ServiceFactory::StopFindService(handle);\n    }\n\n    RequiredInterfaceProxy::HandleType GetHandle() const\n    {\n      return mHandle;\n    }\n\n    proxy::events::LeftCarInBlindSpot LeftCarInBlindSpot;\n    proxy::events::LeftLaneDistance LeftLaneDistance;\n    proxy::events::LeftTurnIndicator LeftTurnIndicator;\n    proxy::events::RightCarInBlindSpot RightCarInBlindSpot;\n    proxy::events::RightLaneDistance RightLaneDistance;\n    proxy::events::RightTurnIndicator RightTurnIndicator;\n  };\n}                                      /* namespace proxy */\n\n#endif                                 // #ifndef REQUIREDINTERFACE_PROXY_H_\n"}],"trace":"{\"model\":\"LaneGuidance\",\"sources\":[\"LaneGuidance.cpp\",\"LaneGuidance.h\"],\"categoricalProps\":[\"ModelElemCategory\",\"StorageClass\"],\"categoricalValues\":[\"InternalData\",\"Default\"],\"sidPrefixes\":[\"LaneGuidance\"],\"fileRecords\":{\"0\":{\"records\":[{\"tk\":[35,13,35,14],\"els\":[\"0:111\"]},{\"tk\":[35,15,35,22],\"els\":[\"0:111\"]},{\"tk\":[42,3,42,17],\"els\":[\"0:144#out:1\"]},{\"tk\":[42,18,42,30],\"els\":[\"0:144#out:1\"]},{\"tk\":[49,3,49,17],\"els\":[\"0:146#out:1\"]},{\"tk\":[49,18,49,31],\"els\":[\"0:146#out:1\"]},{\"tk\":[56,3,56,17],\"els\":[\"0:147#out:1\"]},{\"tk\":[56,18,56,31],\"els\":[\"0:147#out:1\"]},{\"tk\":[63,3,63,17],\"els\":[\"0:148#out:1\"]},{\"tk\":[63,18,63,31],\"els\":[\"0:148#out:1\"]},{\"tk\":[70,3,70,17],\"els\":[\"0:149#out:1\"]},{\"tk\":[70,18,70,31],\"els\":[\"0:149#out:1\"]},{\"tk\":[77,3,77,17],\"els\":[\"0:150#out:1\"]},{\"tk\":[77,18,77,31],\"els\":[\"0:150#out:1\"]},{\"tk\":[114,3,114,5],\"els\":[\"0:109\"]},{\"tk\":[114,7,114,21],\"els\":[\"0:109\"]},{\"tk\":[114,22,114,35],\"els\":[\"0:109\"]},{\"tk\":[114,36,114,37],\"els\":[\"0:109\"]},{\"tk\":[114,38,114,41],\"els\":[\"0:109\"]},{\"tk\":[118,5,118,28],\"els\":[\"0:110\",\"0:109\",\"0:112\",\"0:115\"]},{\"tk\":[118,28,118,29],\"els\":[\"0:110\",\"0:109\",\"0:112\",\"0:115\"]},{\"tk\":[118,29,118,32],\"els\":[\"0:110\",\"0:109\",\"0:112\",\"0:115\"]},{\"tk\":[118,32,118,33],\"els\":[\"0:110\",\"0:109\",\"0:112\",\"0:115\"]},{\"tk\":[118,34,118,35],\"els\":[\"0:110\",\"0:109\",\"0:112\",\"0:115\"]},{\"tk\":[118,35,118,45],\"els\":[\"0:110\",\"0:109\",\"0:112\",\"0:115\",\"0:137#out:1\"]},{\"tk\":[118,45,118,46],\"els\":[\"0:110\",\"0:109\",\"0:112\",\"0:115\"]},{\"tk\":[121,10,121,12],\"els\":[\"0:109\"]},{\"tk\":[121,15,121,29],\"els\":[\"0:109\"]},{\"tk\":[121,30,121,43],\"els\":[\"0:109\"]},{\"tk\":[121,44,121,46],\"els\":[\"0:109\"]},{\"tk\":[121,47,121,50],\"els\":[\"0:109\"]},{\"tk\":[121,52,121,54],\"els\":[\"0:109\"]},{\"tk\":[122,15,122,29],\"els\":[\"0:109\"]},{\"tk\":[122,30,122,42],\"els\":[\"0:109\"]},{\"tk\":[122,43,122,44],\"els\":[\"0:109\"]},{\"tk\":[122,45,122,48],\"els\":[\"0:109\",\"0:82\"]},{\"tk\":[126,5,126,28],\"els\":[\"0:116\",\"0:109\",\"0:118\",\"0:114\"]},{\"tk\":[126,28,126,29],\"els\":[\"0:116\",\"0:109\",\"0:118\",\"0:114\"]},{\"tk\":[126,29,126,32],\"els\":[\"0:116\",\"0:109\",\"0:118\",\"0:114\"]},{\"tk\":[126,32,126,33],\"els\":[\"0:116\",\"0:109\",\"0:118\",\"0:114\"]},{\"tk\":[126,34,126,35],\"els\":[\"0:116\",\"0:109\",\"0:118\",\"0:114\"]},{\"tk\":[126,35,126,45],\"els\":[\"0:116\",\"0:109\",\"0:118\",\"0:114\",\"0:137#out:1\"]},{\"tk\":[126,45,126,46],\"els\":[\"0:116\",\"0:109\",\"0:118\",\"0:114\"]},{\"tk\":[133,5,133,28],\"els\":[\"0:120\",\"0:109\",\"0:122\",\"0:115\"]},{\"tk\":[133,28,133,29],\"els\":[\"0:120\",\"0:109\",\"0:122\",\"0:115\"]},{\"tk\":[133,29,133,32],\"els\":[\"0:120\",\"0:109\",\"0:122\",\"0:115\"]},{\"tk\":[133,32,133,33],\"els\":[\"0:120\",\"0:109\",\"0:122\",\"0:115\"]},{\"tk\":[133,34,133,35],\"els\":[\"0:120\",\"0:109\",\"0:122\",\"0:115\"]},{\"tk\":[133,35,133,45],\"els\":[\"0:120\",\"0:109\",\"0:122\",\"0:115\",\"0:137#out:1\"]},{\"tk\":[133,45,133,46],\"els\":[\"0:120\",\"0:109\",\"0:122\",\"0:115\"]},{\"tk\":[142,42,142,52],\"els\":[\"0:137#out:1\"]},{\"tk\":[172,3,172,5],\"els\":[\"0:138\"]},{\"tk\":[172,7,172,21],\"els\":[\"0:138\"]},{\"tk\":[172,22,172,35],\"els\":[\"0:138\"]},{\"tk\":[172,36,172,37],\"els\":[\"0:138\"]},{\"tk\":[172,38,172,41],\"els\":[\"0:138\"]},{\"tk\":[176,5,176,28],\"els\":[\"0:125\",\"0:138\",\"0:127\",\"0:115\"]},{\"tk\":[176,28,176,29],\"els\":[\"0:125\",\"0:138\",\"0:127\",\"0:115\"]},{\"tk\":[176,29,176,32],\"els\":[\"0:125\",\"0:138\",\"0:127\",\"0:115\"]},{\"tk\":[176,32,176,33],\"els\":[\"0:125\",\"0:138\",\"0:127\",\"0:115\"]},{\"tk\":[176,34,176,35],\"els\":[\"0:125\",\"0:138\",\"0:127\",\"0:115\"]},{\"tk\":[176,35,176,45],\"els\":[\"0:125\",\"0:138\",\"0:127\",\"0:115\",\"0:137#out:1\"]},{\"tk\":[176,45,176,46],\"els\":[\"0:125\",\"0:138\",\"0:127\",\"0:115\"]},{\"tk\":[179,10,179,12],\"els\":[\"0:138\"]},{\"tk\":[179,15,179,29],\"els\":[\"0:138\"]},{\"tk\":[179,30,179,43],\"els\":[\"0:138\"]},{\"tk\":[179,44,179,46],\"els\":[\"0:138\"]},{\"tk\":[179,47,179,50],\"els\":[\"0:138\"]},{\"tk\":[179,52,179,54],\"els\":[\"0:138\"]},{\"tk\":[180,15,180,29],\"els\":[\"0:138\"]},{\"tk\":[180,30,180,43],\"els\":[\"0:138\"]},{\"tk\":[180,44,180,45],\"els\":[\"0:138\"]},{\"tk\":[180,46,180,49],\"els\":[\"0:138\",\"0:82\"]},{\"tk\":[184,5,184,28],\"els\":[\"0:129\",\"0:138\",\"0:131\",\"0:114\"]},{\"tk\":[184,28,184,29],\"els\":[\"0:129\",\"0:138\",\"0:131\",\"0:114\"]},{\"tk\":[184,29,184,32],\"els\":[\"0:129\",\"0:138\",\"0:131\",\"0:114\"]},{\"tk\":[184,32,184,33],\"els\":[\"0:129\",\"0:138\",\"0:131\",\"0:114\"]},{\"tk\":[184,34,184,35],\"els\":[\"0:129\",\"0:138\",\"0:131\",\"0:114\"]},{\"tk\":[184,35,184,45],\"els\":[\"0:129\",\"0:138\",\"0:131\",\"0:114\",\"0:137#out:1\"]},{\"tk\":[184,45,184,46],\"els\":[\"0:129\",\"0:138\",\"0:131\",\"0:114\"]},{\"tk\":[191,5,191,28],\"els\":[\"0:133\",\"0:138\",\"0:135\",\"0:115\"]},{\"tk\":[191,28,191,29],\"els\":[\"0:133\",\"0:138\",\"0:135\",\"0:115\"]},{\"tk\":[191,29,191,32],\"els\":[\"0:133\",\"0:138\",\"0:135\",\"0:115\"]},{\"tk\":[191,32,191,33],\"els\":[\"0:133\",\"0:138\",\"0:135\",\"0:115\"]},{\"tk\":[191,34,191,35],\"els\":[\"0:133\",\"0:138\",\"0:135\",\"0:115\"]},{\"tk\":[191,35,191,45],\"els\":[\"0:133\",\"0:138\",\"0:135\",\"0:115\",\"0:137#out:1\"]},{\"tk\":[191,45,191,46],\"els\":[\"0:133\",\"0:138\",\"0:135\",\"0:115\"]},{\"tk\":[200,43,200,53],\"els\":[\"0:137#out:1\"]}]},\"1\":{\"records\":[{\"tk\":[38,5,38,11],\"els\":[\"1:144\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[38,12,38,24],\"els\":[\"1:144\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[38,24,38,25],\"els\":[\"1:144\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[39,5,39,11],\"els\":[\"1:146\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[39,12,39,25],\"els\":[\"1:146\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[39,25,39,26],\"els\":[\"1:146\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[40,5,40,11],\"els\":[\"1:147\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[40,12,40,25],\"els\":[\"1:147\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[40,25,40,26],\"els\":[\"1:147\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[41,5,41,11],\"els\":[\"1:148\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[41,12,41,25],\"els\":[\"1:148\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[41,25,41,26],\"els\":[\"1:148\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[42,5,42,11],\"els\":[\"1:149\"],\"ct\":{\"1\":1,\"0\":0}},{\"tk\":[42,12,42,25],\"els\":[\"1:149\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[42,25,42,26],\"els\":[\"1:149\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[43,5,43,11],\"els\":[\"1:150\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[43,12,43,25],\"els\":[\"1:150\"],\"ct\":{\"0\":0,\"1\":1}},{\"tk\":[43,25,43,26],\"els\":[\"1:150\"],\"ct\":{\"1\":1,\"0\":0}}]}}}","blocks":[{"RTWName":"<Root>/leftLaneDistance","SIDString":"LaneGuidance:74"},{"RTWName":"<Root>/leftTurnIndicator","SIDString":"LaneGuidance:89"},{"RTWName":"<Root>/rightLaneDistance","SIDString":"LaneGuidance:75"},{"RTWName":"<Root>/rightTurnIndicator","SIDString":"LaneGuidance:90"},{"RTWName":"<Root>/leftCarInBlindSpot","SIDString":"LaneGuidance:93"},{"RTWName":"<Root>/rightCarInBlindSpot","SIDString":"LaneGuidance:94"},{"RTWName":"<Root>/Event Receive","SIDString":"LaneGuidance:144"},{"RTWName":"<Root>/Event Receive1","SIDString":"LaneGuidance:146"},{"RTWName":"<Root>/Event Receive2","SIDString":"LaneGuidance:147"},{"RTWName":"<Root>/Event Receive3","SIDString":"LaneGuidance:148"},{"RTWName":"<Root>/Event Receive4","SIDString":"LaneGuidance:149"},{"RTWName":"<Root>/Event Receive5","SIDString":"LaneGuidance:150"},{"RTWName":"<Root>/Event Send","SIDString":"LaneGuidance:145"},{"RTWName":"<Root>/Event Send1","SIDString":"LaneGuidance:151"},{"RTWName":"<S1>/LeftLaneDistance","SIDString":"LaneGuidance:79"},{"RTWName":"<S1>/LeftTurnIndicator","SIDString":"LaneGuidance:83"},{"RTWName":"<S1>/LeftCarInBlindSpot","SIDString":"LaneGuidance:86"},{"RTWName":"<S1>/RightLaneDistance","SIDString":"LaneGuidance:81"},{"RTWName":"<S1>/RightTurnIndicator","SIDString":"LaneGuidance:84"},{"RTWName":"<S1>/RightCarInBlindSpot","SIDString":"LaneGuidance:85"},{"RTWName":"<S1>/Constant","SIDString":"LaneGuidance:82"},{"RTWName":"<S1>/Constant1","SIDString":"LaneGuidance:114"},{"RTWName":"<S1>/Constant2","SIDString":"LaneGuidance:115"},{"RTWName":"<S1>/If","SIDString":"LaneGuidance:109"},{"RTWName":"<S1>/If1","SIDString":"LaneGuidance:138"},{"RTWName":"<S2>/In1","SIDString":"LaneGuidance:111"},{"RTWName":"<S2>/Action Port","SIDString":"LaneGuidance:112"},{"RTWName":"<S2>/Out1","SIDString":"LaneGuidance:113"},{"RTWName":"<S3>/In1","SIDString":"LaneGuidance:117"},{"RTWName":"<S3>/Action Port","SIDString":"LaneGuidance:118"},{"RTWName":"<S3>/Out1","SIDString":"LaneGuidance:119"},{"RTWName":"<S4>/In1","SIDString":"LaneGuidance:121"},{"RTWName":"<S4>/Action Port","SIDString":"LaneGuidance:122"},{"RTWName":"<S4>/Out1","SIDString":"LaneGuidance:123"},{"RTWName":"<S5>/In1","SIDString":"LaneGuidance:126"},{"RTWName":"<S5>/Action Port","SIDString":"LaneGuidance:127"},{"RTWName":"<S5>/Out1","SIDString":"LaneGuidance:128"},{"RTWName":"<S6>/In1","SIDString":"LaneGuidance:130"},{"RTWName":"<S6>/Action Port","SIDString":"LaneGuidance:131"},{"RTWName":"<S6>/Out1","SIDString":"LaneGuidance:132"},{"RTWName":"<S7>/In1","SIDString":"LaneGuidance:134"},{"RTWName":"<S7>/Action Port","SIDString":"LaneGuidance:135"},{"RTWName":"<S7>/Out1","SIDString":"LaneGuidance:136"},{"RTWName":"<S1>/Merge","SIDString":"LaneGuidance:124"},{"RTWName":"<S1>/Merge1","SIDString":"LaneGuidance:137"},{"RTWName":"<S1>/leftHazardIndicator","SIDString":"LaneGuidance:80"},{"RTWName":"<S1>/rightHazardIndicator","SIDString":"LaneGuidance:96"},{"RTWName":"<Root>/leftHazardIndicator","SIDString":"LaneGuidance:46"},{"RTWName":"<Root>/rightHazardIndicator","SIDString":"LaneGuidance:98"},{"RTWName":"<Root>/LaneGuidanceAlgorithm","SIDString":"LaneGuidance:78"},{"RTWName":"<S1>/IfActionSS","SIDString":"LaneGuidance:110"},{"RTWName":"<S1>/IfActionSS1","SIDString":"LaneGuidance:116"},{"RTWName":"<S1>/IfActionSS2","SIDString":"LaneGuidance:120"},{"RTWName":"<S1>/IfActionSS3","SIDString":"LaneGuidance:125"},{"RTWName":"<S1>/IfActionSS4","SIDString":"LaneGuidance:129"},{"RTWName":"<S1>/IfActionSS5","SIDString":"LaneGuidance:133"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true}};